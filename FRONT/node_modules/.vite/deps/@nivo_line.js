import {
  require_isDate,
  require_sortBy,
  require_uniq,
  require_uniqBy
} from "./chunk-MUJ7T3CG.js";
import "./chunk-V4JCSUZQ.js";
import {
  Accent_default,
  At,
  Bi,
  Blues_default,
  BrBG_default,
  BuGn_default,
  BuPu_default,
  Dark2_default,
  Ei,
  Fi,
  Ft,
  GnBu_default,
  Greens_default,
  Greys_default,
  Ji,
  Mi,
  Mt,
  OrRd_default,
  Oranges_default,
  PRGn_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  PiYG_default,
  PuBuGn_default,
  PuBu_default,
  PuOr_default,
  PuRd_default,
  Purples_default,
  Qi,
  RdBu_default,
  RdGy_default,
  RdPu_default,
  RdYlBu_default,
  RdYlGn_default,
  Reds_default,
  Rt,
  Set1_default,
  Set2_default,
  Set3_default,
  Si,
  Spectral_default,
  Vt,
  Xt,
  YlGnBu_default,
  YlGn_default,
  YlOrBr_default,
  YlOrRd_default,
  area_default,
  band,
  category10_default,
  cividis_default,
  cool,
  cubehelix_default,
  et,
  format,
  friday,
  hour_default,
  inferno,
  it,
  kt,
  line_default,
  linear,
  log,
  magma,
  millisecond_default,
  minute_default,
  monday,
  month_default,
  newInterval,
  ordinal,
  plasma,
  point,
  qt,
  rainbow_default,
  require_isPlainObject,
  require_last,
  rgb,
  rn,
  saturday,
  scheme,
  scheme10,
  scheme11,
  scheme12,
  scheme13,
  scheme14,
  scheme15,
  scheme16,
  scheme17,
  scheme18,
  scheme19,
  scheme2,
  scheme20,
  scheme21,
  scheme22,
  scheme23,
  scheme24,
  scheme25,
  scheme26,
  scheme27,
  scheme3,
  scheme4,
  scheme5,
  scheme6,
  scheme7,
  scheme8,
  scheme9,
  second_default,
  sinebow_default,
  sunday,
  symlog,
  thursday,
  ti,
  time,
  timeFormat,
  timeParse,
  tt,
  tuesday,
  turbo_default,
  ui,
  utcFriday,
  utcHour_default,
  utcMinute_default,
  utcMonday,
  utcMonth_default,
  utcParse,
  utcSaturday,
  utcSunday,
  utcThursday,
  utcTime,
  utcTuesday,
  utcWednesday,
  utcYear_default,
  viridis_default,
  warm,
  wednesday,
  year_default,
  yi
} from "./chunk-ZBNF3JJ2.js";
import {
  require_get
} from "./chunk-OAFUNSKW.js";
import {
  require_react_dom
} from "./chunk-GSZ7ISAW.js";
import {
  require_jsx_runtime,
  require_prop_types
} from "./chunk-GTT32NLA.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@nivo/line/dist/nivo-line.es.js
var import_react9 = __toESM(require_react());

// node_modules/@nivo/line/node_modules/@nivo/colors/dist/nivo-colors.es.js
var import_isPlainObject = __toESM(require_isPlainObject());
var import_get = __toESM(require_get());
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
function qe() {
  return qe = Object.assign || function(e7) {
    for (var r5 = 1; r5 < arguments.length; r5++) {
      var n6 = arguments[r5];
      for (var t7 in n6)
        Object.prototype.hasOwnProperty.call(n6, t7) && (e7[t7] = n6[t7]);
    }
    return e7;
  }, qe.apply(this, arguments);
}
function Re(e7, r5) {
  (null == r5 || r5 > e7.length) && (r5 = e7.length);
  for (var n6 = 0, t7 = new Array(r5); n6 < r5; n6++)
    t7[n6] = e7[n6];
  return t7;
}
function Se(e7, r5) {
  var n6 = "undefined" != typeof Symbol && e7[Symbol.iterator] || e7["@@iterator"];
  if (n6)
    return (n6 = n6.call(e7)).next.bind(n6);
  if (Array.isArray(e7) || (n6 = function(e8, r6) {
    if (e8) {
      if ("string" == typeof e8)
        return Re(e8, r6);
      var n7 = Object.prototype.toString.call(e8).slice(8, -1);
      return "Object" === n7 && e8.constructor && (n7 = e8.constructor.name), "Map" === n7 || "Set" === n7 ? Array.from(e8) : "Arguments" === n7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n7) ? Re(e8, r6) : void 0;
    }
  }(e7)) || r5 && e7 && "number" == typeof e7.length) {
    n6 && (e7 = n6);
    var t7 = 0;
    return function() {
      return t7 >= e7.length ? { done: true } : { done: false, value: e7[t7++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var Ce = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default };
var Ge = Object.keys(Ce);
var Ve = { brown_blueGreen: scheme, purpleRed_green: scheme2, pink_yellowGreen: scheme3, purple_orange: scheme4, red_blue: scheme5, red_grey: scheme6, red_yellow_blue: scheme7, red_yellow_green: scheme8, spectral: scheme9 };
var Te = Object.keys(Ve);
var Pe = { brown_blueGreen: BrBG_default, purpleRed_green: PRGn_default, pink_yellowGreen: PiYG_default, purple_orange: PuOr_default, red_blue: RdBu_default, red_grey: RdGy_default, red_yellow_blue: RdYlBu_default, red_yellow_green: RdYlGn_default, spectral: Spectral_default };
var Ue = { blues: scheme22, greens: scheme23, greys: scheme24, oranges: scheme27, purples: scheme25, reds: scheme26, blue_green: scheme10, blue_purple: scheme11, green_blue: scheme12, orange_red: scheme13, purple_blue_green: scheme14, purple_blue: scheme15, purple_red: scheme16, red_purple: scheme17, yellow_green_blue: scheme18, yellow_green: scheme19, yellow_orange_brown: scheme20, yellow_orange_red: scheme21 };
var De = Object.keys(Ue);
var Me = { blues: Blues_default, greens: Greens_default, greys: Greys_default, oranges: Oranges_default, purples: Purples_default, reds: Reds_default, turbo: turbo_default, viridis: viridis_default, inferno, magma, plasma, cividis: cividis_default, warm, cool, cubehelixDefault: cubehelix_default, blue_green: BuGn_default, blue_purple: BuPu_default, green_blue: GnBu_default, orange_red: OrRd_default, purple_blue_green: PuBuGn_default, purple_blue: PuBu_default, purple_red: PuRd_default, red_purple: RdPu_default, yellow_green_blue: YlGnBu_default, yellow_green: YlGn_default, yellow_orange_brown: YlOrBr_default, yellow_orange_red: YlOrRd_default };
var $e = qe({}, Ce, Ve, Ue);
var Be = Object.keys($e);
var Fe = function(e7) {
  return Ge.includes(e7);
};
var He = function(e7) {
  return Te.includes(e7);
};
var Je = function(e7) {
  return De.includes(e7);
};
var Ke = { rainbow: rainbow_default, sinebow: sinebow_default };
var Le = qe({}, Pe, Me, Ke);
var Ne = Object.keys(Le);
var Qe = function(e7, r5) {
  if ("function" == typeof e7)
    return e7;
  if ((0, import_isPlainObject.default)(e7)) {
    if (function(e8) {
      return void 0 !== e8.theme;
    }(e7)) {
      if (void 0 === r5)
        throw new Error("Unable to use color from theme as no theme was provided");
      var n6 = (0, import_get.default)(r5, e7.theme);
      if (void 0 === n6)
        throw new Error("Color from theme is undefined at path: '" + e7.theme + "'");
      return function() {
        return n6;
      };
    }
    if (function(e8) {
      return void 0 !== e8.from;
    }(e7)) {
      var t7 = function(r6) {
        return (0, import_get.default)(r6, e7.from);
      };
      if (Array.isArray(e7.modifiers)) {
        for (var o4, i5 = [], u2 = function() {
          var e8 = o4.value, r6 = e8[0], n7 = e8[1];
          if ("brighter" === r6)
            i5.push(function(e9) {
              return e9.brighter(n7);
            });
          else if ("darker" === r6)
            i5.push(function(e9) {
              return e9.darker(n7);
            });
          else {
            if ("opacity" !== r6)
              throw new Error("Invalid color modifier: '" + r6 + "', must be one of: 'brighter', 'darker', 'opacity'");
            i5.push(function(e9) {
              return e9.opacity = n7, e9;
            });
          }
        }, a4 = Se(e7.modifiers); !(o4 = a4()).done; )
          u2();
        return 0 === i5.length ? t7 : function(e8) {
          return i5.reduce(function(e9, r6) {
            return r6(e9);
          }, rgb(t7(e8))).toString();
        };
      }
      return t7;
    }
    throw new Error("Invalid color spec, you should either specify 'theme' or 'from' when using a config object");
  }
  return function() {
    return e7;
  };
};
var We = function(e7, r5) {
  return (0, import_react.useMemo)(function() {
    return Qe(e7, r5);
  }, [e7, r5]);
};
var Xe = import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.arrayOf(import_prop_types.default.string), import_prop_types.default.shape({ scheme: import_prop_types.default.oneOf(Be).isRequired, size: import_prop_types.default.number }), import_prop_types.default.shape({ datum: import_prop_types.default.string.isRequired }), import_prop_types.default.string]);
var Ye = import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func, import_prop_types.default.shape({ theme: import_prop_types.default.string.isRequired }), import_prop_types.default.shape({ from: import_prop_types.default.string.isRequired, modifiers: import_prop_types.default.arrayOf(import_prop_types.default.array) })]);
var fr = function(e7, r5) {
  if ("function" == typeof e7)
    return e7;
  var n6 = "function" == typeof r5 ? r5 : function(e8) {
    return (0, import_get.default)(e8, r5);
  };
  if (Array.isArray(e7)) {
    var t7 = ordinal(e7), o4 = function(e8) {
      return t7(n6(e8));
    };
    return o4.scale = t7, o4;
  }
  if ((0, import_isPlainObject.default)(e7)) {
    if (function(e8) {
      return void 0 !== e8.datum;
    }(e7))
      return function(r6) {
        return (0, import_get.default)(r6, e7.datum);
      };
    if (function(e8) {
      return void 0 !== e8.scheme;
    }(e7)) {
      if (Fe(e7.scheme)) {
        var i5 = ordinal($e[e7.scheme]), u2 = function(e8) {
          return i5(n6(e8));
        };
        return u2.scale = i5, u2;
      }
      if (He(e7.scheme)) {
        if (void 0 !== e7.size && (e7.size < 3 || e7.size > 11))
          throw new Error("Invalid size '" + e7.size + "' for diverging color scheme '" + e7.scheme + "', must be between 3~11");
        var a4 = ordinal($e[e7.scheme][e7.size || 11]), s3 = function(e8) {
          return a4(n6(e8));
        };
        return s3.scale = a4, s3;
      }
      if (Je(e7.scheme)) {
        if (void 0 !== e7.size && (e7.size < 3 || e7.size > 9))
          throw new Error("Invalid size '" + e7.size + "' for sequential color scheme '" + e7.scheme + "', must be between 3~9");
        var c2 = ordinal($e[e7.scheme][e7.size || 9]), l3 = function(e8) {
          return c2(n6(e8));
        };
        return l3.scale = c2, l3;
      }
    }
    throw new Error("Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property");
  }
  return function() {
    return e7;
  };
};
var dr = function(e7, r5) {
  return (0, import_react.useMemo)(function() {
    return fr(e7, r5);
  }, [e7, r5]);
};

// node_modules/@nivo/line/node_modules/@nivo/axes/dist/nivo-axes.es.js
var t2 = __toESM(require_react());
var import_react5 = __toESM(require_react());

// node_modules/@nivo/line/node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
var updateQueue = makeQueue();
var raf = (fn2) => schedule(fn2, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn2) => schedule(fn2, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn2) => schedule(fn2, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn2) => schedule(fn2, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn2) => schedule(fn2, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  let time2 = raf.now() + ms;
  let cancel = () => {
    let i5 = timeouts.findIndex((t7) => t7.cancel == cancel);
    if (~i5)
      timeouts.splice(i5, 1);
    __raf.count -= ~i5 ? 1 : 0;
  };
  let timeout = {
    time: time2,
    handler,
    cancel
  };
  timeouts.splice(findTimeout(time2), 0, timeout);
  __raf.count += 1;
  start();
  return timeout;
};
var findTimeout = (time2) => ~(~timeouts.findIndex((t7) => t7.time > time2) || ~timeouts.length);
raf.cancel = (fn2) => {
  updateQueue.delete(fn2);
  writeQueue.delete(fn2);
};
raf.sync = (fn2) => {
  sync = true;
  raf.batchedUpdates(fn2);
  sync = false;
};
raf.throttle = (fn2) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn2(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn2;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
};
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn2) => fn2();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
  } else {
    update();
  }
};
var ts = -1;
var sync = false;
function schedule(fn2, queue) {
  if (sync) {
    queue.delete(fn2);
    fn2(0);
  } else {
    queue.add(fn2);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  let prevTs = ts;
  ts = raf.now();
  let count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t7) => t7.handler());
    __raf.count -= count;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn2) {
      __raf.count += current == next && !next.has(fn2) ? 1 : 0;
      next.add(fn2);
    },
    delete(fn2) {
      __raf.count -= current == next && next.has(fn2) ? 1 : 0;
      return next.delete(fn2);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        __raf.count -= current.size;
        eachSafely(current, (fn2) => fn2(arg) && next.add(fn2));
        __raf.count += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e7) {
      raf.catch(e7);
    }
  });
}
var __raf = {
  count: 0,
  clear() {
    ts = -1;
    timeouts = [];
    onStartQueue = makeQueue();
    updateQueue = makeQueue();
    onFrameQueue = makeQueue();
    writeQueue = makeQueue();
    onFinishQueue = makeQueue();
    __raf.count = 0;
  }
};

// node_modules/@nivo/line/node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
  value,
  writable: true,
  configurable: true
});
var is = {
  arr: Array.isArray,
  obj: (a4) => !!a4 && a4.constructor.name === "Object",
  fun: (a4) => typeof a4 === "function",
  str: (a4) => typeof a4 === "string",
  num: (a4) => typeof a4 === "number",
  und: (a4) => a4 === void 0
};
function isEqual(a4, b5) {
  if (is.arr(a4)) {
    if (!is.arr(b5) || a4.length !== b5.length)
      return false;
    for (let i5 = 0; i5 < a4.length; i5++) {
      if (a4[i5] !== b5[i5])
        return false;
    }
    return true;
  }
  return a4 === b5;
}
var each = (obj, fn2) => obj.forEach(fn2);
function eachProp(obj, fn2, ctx2) {
  if (is.arr(obj)) {
    for (let i5 = 0; i5 < obj.length; i5++) {
      fn2.call(ctx2, obj[i5], `${i5}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn2.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a4) => is.und(a4) ? [] : is.arr(a4) ? a4 : [a4];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn2) => fn2(...args));
var createStringInterpolator$1;
var to;
var colors$1 = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals2) => {
  if (globals2.to)
    to = globals2.to;
  if (globals2.now)
    raf.now = globals2.now;
  if (globals2.colors !== void 0)
    colors$1 = globals2.colors;
  if (globals2.skipAnimation != null)
    skipAnimation = globals2.skipAnimation;
  if (globals2.createStringInterpolator)
    createStringInterpolator$1 = globals2.createStringInterpolator;
  if (globals2.requestAnimationFrame)
    raf.use(globals2.requestAnimationFrame);
  if (globals2.batchedUpdates)
    raf.batchedUpdates = globals2.batchedUpdates;
  if (globals2.willAdvance)
    willAdvance = globals2.willAdvance;
  if (globals2.frameLoop)
    raf.frameLoop = globals2.frameLoop;
};
var globals = Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return createStringInterpolator$1;
  },
  get to() {
    return to;
  },
  get colors() {
    return colors$1;
  },
  get skipAnimation() {
    return skipAnimation;
  },
  get willAdvance() {
    return willAdvance;
  },
  assign
});
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  advance,
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i5 = 0; i5 < currentFrame.length; i5++) {
    const animation = currentFrame[i5];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb2 = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors$1 && colors$1[color] !== void 0) {
    return colors$1[color];
  }
  if (match = rgb2.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
  }
  return null;
}
function hue2rgb(p5, q, t7) {
  if (t7 < 0)
    t7 += 1;
  if (t7 > 1)
    t7 -= 1;
  if (t7 < 1 / 6)
    return p5 + (q - p5) * 6 * t7;
  if (t7 < 1 / 2)
    return q;
  if (t7 < 2 / 3)
    return p5 + (q - p5) * (2 / 3 - t7) * 6;
  return p5;
}
function hslToRgb(h3, s3, l3) {
  const q = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
  const p5 = 2 * l3 - q;
  const r5 = hue2rgb(p5, q, h3 + 1 / 3);
  const g5 = hue2rgb(p5, q, h3);
  const b5 = hue2rgb(p5, q, h3 - 1 / 3);
  return Math.round(r5 * 255) << 24 | Math.round(g5 * 255) << 16 | Math.round(b5 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  let r5 = (int32Color & 4278190080) >>> 24;
  let g5 = (int32Color & 16711680) >>> 16;
  let b5 = (int32Color & 65280) >>> 8;
  let a4 = (int32Color & 255) / 255;
  return `rgba(${r5}, ${g5}, ${b5}, ${a4})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator$1(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t7) => t7);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i5 = 1; i5 < inputRange.length - 1; ++i5)
    if (inputRange[i5] >= input)
      break;
  return i5 - 1;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer, event) {
  if (observer.eventObserved) {
    observer.eventObserved(event);
  } else {
    observer(event);
  }
}
function callFluidObservers(target, event) {
  let observers = target[$observers];
  if (observers) {
    observers.forEach((observer) => {
      callFluidObserver(observer, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    this[$get] = void 0;
    this[$observers] = void 0;
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer)) {
      observers.add(observer);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer);
      }
    }
  }
  return observer;
}
function removeFluidObserver(target, observer) {
  let observers = target[$observers];
  if (observers && observers.has(observer)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var namedColorRegex;
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var rgbaRound = (_2, p1, p22, p32, p42) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p32)}, ${p42})`;
var createStringInterpolator = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
  const output = config2.output.map((value) => getFluidValue(value).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba));
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map((_2, i5) => keyframes.map((values) => {
    if (!(i5 in values)) {
      throw Error('The arity of each "output" value must be equal');
    }
    return values[i5];
  }));
  const interpolators = outputRanges.map((output2) => createInterpolator(_extends({}, config2, {
    output: output2
  })));
  return (input) => {
    var _output$find;
    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
    let i5 = 0;
    return output[0].replace(numberRegex, () => `${interpolators[i5++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn2) => {
  const func = fn2;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || value in (colors$1 || {}));
}
var useOnce = (effect) => (0, import_react2.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function useForceUpdate() {
  const update3 = (0, import_react2.useState)()[1];
  const mounted = (0, import_react2.useState)(makeMountedRef)[0];
  useOnce(mounted.unmount);
  return () => {
    if (mounted.current) {
      update3({});
    }
  };
}
function makeMountedRef() {
  const mounted = {
    current: true,
    unmount: () => () => {
      mounted.current = false;
    }
  };
  return mounted;
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react2.useState)(() => ({
    inputs,
    result: getResult()
  }));
  const committed = (0, import_react2.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react2.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i5 = 0; i5 < next.length; i5++) {
    if (next[i5] !== prev[i5]) {
      return false;
    }
  }
  return true;
}
function usePrev(value) {
  const prevRef = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}
var useLayoutEffect2 = typeof window !== "undefined" && window.document && window.document.createElement ? React.useLayoutEffect : React.useEffect;

// node_modules/@nivo/line/node_modules/@react-spring/core/dist/react-spring-core.esm.js
var React3 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/@nivo/line/node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
var React2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    this.payload = void 0;
    setAnimated(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class _AnimatedValue extends Animated {
  constructor(_value) {
    super();
    this.done = true;
    this.elapsedTime = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.v0 = void 0;
    this.durationProgress = 0;
    this._value = _value;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  static create(value) {
    return new _AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const {
      done
    } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class _AnimatedString extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = void 0;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  static create(value) {
    return new _AnimatedString(value);
  }
  getValue() {
    let value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = {
  dependencies: null
};
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class _AnimatedArray extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  static create(source) {
    return new _AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i5) => node.setValue(source[i5])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var withAnimated = (Component, host2) => {
  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return (0, import_react3.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react3.useRef)(null);
    const ref = hasInstance && (0, import_react3.useCallback)((value) => {
      instanceRef.current = updateRef(givenRef, value);
    }, [givenRef]);
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react3.useRef)();
    useLayoutEffect2(() => {
      const lastObserver = observerRef.current;
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      if (lastObserver) {
        each(lastObserver.deps, (dep) => removeFluidObserver(dep, lastObserver));
        raf.cancel(lastObserver.update);
      }
    });
    (0, import_react3.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React2.createElement(Component, _extends2({}, usedProps, {
      ref
    }));
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = _extends2({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: _applyAnimatedValues = () => false,
  createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps: _getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@nivo/line/node_modules/@react-spring/core/dist/react-spring-core.esm.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = {
      to: to2
    };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return _extends3({}, props);
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _2 in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  var _ctrl$ref;
  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    var _ctrl$ref2;
    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
var linear2 = (t7) => t7;
var defaults = _extends3({}, config.default, {
  mass: 1,
  damping: 1,
  easing: linear2,
  clamp: false
});
var AnimationConfig = class {
  constructor() {
    this.tension = void 0;
    this.friction = void 0;
    this.frequency = void 0;
    this.damping = void 0;
    this.mass = void 0;
    this.velocity = 0;
    this.restVelocity = void 0;
    this.precision = void 0;
    this.progress = void 0;
    this.duration = void 0;
    this.easing = void 0;
    this.clamp = void 0;
    this.bounce = void 0;
    this.decay = void 0;
    this.round = void 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = _extends3({}, defaultConfig);
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = _extends3({}, defaultConfig, newConfig);
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let {
    mass,
    frequency,
    damping
  } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.to = void 0;
    this.from = void 0;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, {
  key,
  props,
  defaultProps,
  state,
  actions
}) {
  return new Promise((resolve, reject) => {
    var _props$cancel;
    let delay;
    let timeout;
    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals.skipAnimation) {
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start(_extends3({}, props, {
          callId,
          cancel
        }), resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to2, props, state, target) {
  const {
    callId,
    parentId,
    onRest
  } = props;
  const {
    asyncTo: prevTo,
    promise: prevPromise
  } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
    let preventBail;
    let bail;
    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
    const bailIfEnded = (bailSignal) => {
      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAniamtionSignal();
      return (async () => {
        if (globals.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? _extends3({}, arg1) : _extends3({}, arg2, {
          to: arg1
        });
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAniamtionSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t7) => t7.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
    this.result = void 0;
  }
};
var SkipAniamtionSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
    this.result = void 0;
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId$1 = 1;
var FrameValue = class extends FluidValue {
  constructor(...args) {
    super(...args);
    this.id = nextId$1++;
    this.key = void 0;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  to(...args) {
    return globals.to(this, args);
  }
  interpolate(...args) {
    deprecateInterpolate();
    return globals.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.key = void 0;
    this.animation = new Animation();
    this.queue = void 0;
    this.defaultProps = {};
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? _extends3({}, arg1) : _extends3({}, arg2, {
        from: arg1
      });
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  get hasAnimated() {
    return hasAnimated(this);
  }
  get isAnimating() {
    return isAnimating(this);
  }
  get isPaused() {
    return isPaused(this);
  }
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let {
      config: config2,
      toValues
    } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i5) => {
      if (node2.done)
        return;
      const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i5].lastPosition : toValues[i5];
      let finished = anim.immediate;
      let position = to2;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i5];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i5] : config2.velocity;
        let velocity;
        if (!is.und(config2.duration)) {
          let p5 = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p5 = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p5 = p5 > 1 ? 1 : p5 < 0 ? 0 : p5;
            node2.durationProgress = p5;
          }
          position = from + config2.easing(p5) * (to2 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p5 == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e7 = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e7);
          finished = Math.abs(node2.lastPosition - position) < 0.1;
          velocity = v0 * e7;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n6 = 0; n6 < numSteps; ++n6) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to2 || position > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i5].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  pause() {
    this._update({
      pause: true
    });
  }
  resume() {
    this._update({
      pause: false
    });
  }
  finish() {
    if (isAnimating(this)) {
      const {
        to: to2,
        config: config2
      } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : _extends3({}, arg2, {
        to: to2
      })];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(queue.map((props) => this._update(props))).then((results) => getCombinedResult(this, results));
  }
  stop(cancel) {
    const {
      to: to2
    } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  reset() {
    this._update({
      reset: true
    });
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  _prepareNode(props) {
    const key = this.key || "";
    let {
      to: to2,
      from
    } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = {
      to: to2,
      from
    };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  _update(_ref, isLoop) {
    let props = _extends3({}, _ref);
    const {
      key,
      defaultProps
    } = this;
    if (props.default)
      Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const {
      key,
      defaultProps,
      animation: anim
    } = this;
    const {
      to: prevTo,
      from: prevFrom
    } = anim;
    let {
      to: to2 = prevTo,
      from = prevFrom
    } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const {
      config: config2
    } = anim;
    const {
      decay,
      velocity
    } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const {
          onRest
        } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority2 = to2.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
  let loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate(_extends3({}, props, {
      loop: loop2,
      default: false,
      pause: void 0,
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      from: reset ? props.from : void 0,
      reset
    }, overrides));
  }
}
function createUpdate(props) {
  const {
    to: to2,
    from
  } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update3 = createUpdate(props);
  if (is.und(update3.default)) {
    update3.default = getDefaultProps(update3);
  }
  return update3;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
  (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
  (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId = 1;
var Controller = class {
  constructor(props, flush2) {
    this.id = nextId++;
    this.springs = {};
    this.queue = [];
    this.ref = void 0;
    this._flush = void 0;
    this._initialProps = void 0;
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._item = void 0;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush2) {
      this._flush = flush2;
    }
    if (props) {
      this.start(_extends3({
        default: true
      }, props));
    }
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => spring.idle);
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  start(props) {
    let {
      queue
    } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  pause(keys) {
    if (is.und(keys)) {
      this.start({
        pause: true
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  resume(keys) {
    if (is.und(keys)) {
      this.start({
        pause: false
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  _onFrame() {
    const {
      onStart,
      onChange,
      onRest
    } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
}
async function flushUpdate(ctrl, props, isLoop) {
  const {
    keys,
    to: to2,
    from,
    loop: loop2,
    onRest,
    onResolve
  } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({
          finished,
          cancelled
        }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
      props,
      state,
      actions: {
        pause: noop,
        resume: noop,
        start(props2, resolve) {
          if (cancel) {
            stopAsync(state, ctrl["_lastAsyncId"]);
            resolve(getCancelledResult(ctrl));
          } else {
            props2.onRest = onRest;
            resolve(runAsync(asyncTo, props2, state, ctrl));
          }
        }
      }
    }));
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = _extends3({}, ctrl.springs);
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = _extends3({}, props2, {
          to: void 0
        });
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i5;
  for (i5 = 0; i5 < sourceKeys.length; i5++) {
    key = sourceKeys[i5];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$3 = ["children"];
var SpringContext = (_ref) => {
  let {
    children
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$3);
  const inherited = (0, import_react4.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({
    pause,
    immediate
  }), [pause, immediate]);
  const {
    Provider
  } = ctx;
  return React3.createElement(Provider, {
    value: props
  }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, React3.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function SpringRef3(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i5) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = _getProps(props, ctrl, i5);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i5 = current.indexOf(ctrl);
    if (~i5)
      current.splice(i5, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl) => ctrl.set(values));
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i5) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = this._getProps(props, ctrl, i5);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i5) => ctrl.update(this._getProps(props, ctrl, i5)));
    return this;
  };
  const _getProps = function _getProps2(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0, import_react4.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const layoutId = (0, import_react4.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react4.useMemo)(() => ({
    ctrls: [],
    queue: [],
    flush(ctrl, updates2) {
      const springs2 = getSprings(ctrl, updates2);
      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
        setSprings(ctrl, springs2);
        state.queue.push(() => {
          resolve(flushUpdateQueue(ctrl, updates2));
        });
        forceUpdate();
      });
    }
  }), []);
  const ctrls = (0, import_react4.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react4.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react4.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const ctrl = ctrls.current[i5] || (ctrls.current[i5] = new Controller(null, state.flush));
      const update3 = propsFn ? propsFn(i5, ctrl) : props[i5];
      if (update3) {
        updates[i5] = declareUpdate(update3);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i5) => getSprings(ctrl, updates[i5]));
  const context = (0, import_react4.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useLayoutEffect2(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const {
      queue
    } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i5) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({
          default: context
        });
      }
      const update3 = updates[i5];
      if (update3) {
        replaceRef(ctrl, update3.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update3);
        } else {
          ctrl.start(update3);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x4) => _extends3({}, x4));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
var TransitionPhase;
(function(TransitionPhase2) {
  TransitionPhase2["MOUNT"] = "mount";
  TransitionPhase2["ENTER"] = "enter";
  TransitionPhase2["UPDATE"] = "update";
  TransitionPhase2["LEAVE"] = "leave";
})(TransitionPhase || (TransitionPhase = {}));
function useTransition(data, props, deps) {
  const propsFn = is.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = (0, import_react4.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const items = toArray(data);
  const transitions = [];
  const usedTransitions = (0, import_react4.useRef)(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useLayoutEffect2(() => {
    usedTransitions.current = transitions;
  });
  useOnce(() => () => each(usedTransitions.current, (t7) => {
    if (t7.expired) {
      clearTimeout(t7.expirationId);
    }
    detachRefs(t7.ctrl, ref);
    t7.ctrl.stop(true);
  }));
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useLayoutEffect2(() => each(expired, ({
    ctrl,
    item,
    key
  }) => {
    detachRefs(ctrl, ref);
    callProp(onDestroyed, item, key);
  }));
  const reused = [];
  if (prevTransitions)
    each(prevTransitions, (t7, i5) => {
      if (t7.expired) {
        clearTimeout(t7.expirationId);
        expired.push(t7);
      } else {
        i5 = reused[i5] = keys.indexOf(t7.key);
        if (~i5)
          transitions[i5] = t7;
      }
    });
  each(items, (item, i5) => {
    if (!transitions[i5]) {
      transitions[i5] = {
        key: keys[i5],
        item,
        phase: TransitionPhase.MOUNT,
        ctrl: new Controller()
      };
      transitions[i5].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i5 = -1;
    const {
      leave
    } = propsFn ? propsFn() : props;
    each(reused, (keyIndex, prevIndex) => {
      const t7 = prevTransitions[prevIndex];
      if (~keyIndex) {
        i5 = transitions.indexOf(t7);
        transitions[i5] = _extends3({}, t7, {
          item: items[keyIndex]
        });
      } else if (leave) {
        transitions.splice(++i5, 0, t7);
      }
    });
  }
  if (is.fun(sort)) {
    transitions.sort((a4, b5) => sort(a4.item, b5.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  each(transitions, (t7, i5) => {
    const key = t7.key;
    const prevPhase = t7.phase;
    const p5 = propsFn ? propsFn() : props;
    let to2;
    let phase;
    let propsDelay = callProp(p5.delay || 0, key);
    if (prevPhase == TransitionPhase.MOUNT) {
      to2 = p5.enter;
      phase = TransitionPhase.ENTER;
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != TransitionPhase.LEAVE) {
        if (isLeave) {
          to2 = p5.leave;
          phase = TransitionPhase.LEAVE;
        } else if (to2 = p5.update) {
          phase = TransitionPhase.UPDATE;
        } else
          return;
      } else if (!isLeave) {
        to2 = p5.enter;
        phase = TransitionPhase.ENTER;
      } else
        return;
    }
    to2 = callProp(to2, t7.item, i5);
    to2 = is.obj(to2) ? inferTo(to2) : {
      to: to2
    };
    if (!to2.config) {
      const config2 = propsConfig || defaultProps.config;
      to2.config = callProp(config2, t7.item, i5, phase);
    }
    delay += trail;
    const payload = _extends3({}, defaultProps, {
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p5.immediate,
      reset: false
    }, to2);
    if (phase == TransitionPhase.ENTER && is.und(payload.from)) {
      const _p = propsFn ? propsFn() : props;
      const from = is.und(_p.initial) || prevTransitions ? _p.from : _p.initial;
      payload.from = callProp(from, t7.item, i5);
    }
    const {
      onResolve
    } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t8 = transitions2.find((t9) => t9.key === key);
      if (!t8)
        return;
      if (result.cancelled && t8.phase != TransitionPhase.UPDATE) {
        return;
      }
      if (t8.ctrl.idle) {
        const idle = transitions2.every((t9) => t9.ctrl.idle);
        if (t8.phase == TransitionPhase.LEAVE) {
          const expiry = callProp(expires, t8.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t8.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t8.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t9) => t9.expired)) {
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t7.ctrl, payload);
    changes.set(t7, {
      phase,
      springs,
      payload
    });
  });
  const context = (0, import_react4.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useLayoutEffect2(() => {
    if (hasContext)
      each(transitions, (t7) => {
        t7.ctrl.start({
          default: context
        });
      });
  }, [context]);
  useLayoutEffect2(() => {
    each(changes, ({
      phase,
      payload
    }, t7) => {
      const {
        ctrl
      } = t7;
      t7.phase = phase;
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext && phase == TransitionPhase.ENTER) {
        ctrl.start({
          default: context
        });
      }
      if (payload) {
        replaceRef(ctrl, payload.ref);
        if (ctrl.ref) {
          ctrl.update(payload);
        } else {
          ctrl.start(payload);
        }
      }
    });
  }, reset ? void 0 : deps);
  const renderTransitions = (render) => React3.createElement(React3.Fragment, null, transitions.map((t7, i5) => {
    const {
      springs
    } = changes.get(t7) || t7.ctrl;
    const elem = render(_extends3({}, springs), t7.item, t7, i5);
    return elem && elem.type ? React3.createElement(elem.type, _extends3({}, elem.props, {
      key: is.str(t7.key) || is.num(t7.key) ? t7.key : t7.ctrl.id,
      ref: elem.ref
    })) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, {
  key,
  keys = key
}, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t7 = prevTransitions && prevTransitions.find((t8) => t8.item === item && t8.phase !== TransitionPhase.LEAVE && !reused.has(t8));
      if (t7) {
        reused.add(t7);
        return t7.key;
      }
      return nextKey++;
    });
  }
  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.key = void 0;
    this.idle = true;
    this.calc = void 0;
    this._active = /* @__PURE__ */ new Set();
    this.source = source;
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self) {
  if (!self.idle) {
    self.idle = true;
    each(getPayload(self), (node) => {
      node.done = true;
    });
    callFluidObservers(self, {
      type: "idle",
      parent: self
    });
  }
}
globals.assign({
  createStringInterpolator,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@nivo/line/node_modules/@react-spring/web/dist/react-spring-web.esm.js
var import_react_dom = __toESM(require_react_dom());
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i5;
  for (i5 = 0; i5 < sourceKeys.length; i5++) {
    key = sourceKeys[i5];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$2 = ["style", "children", "scrollTop", "scrollLeft"];
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _ref = props, {
    style,
    children,
    scrollTop,
    scrollLeft
  } = _ref, attributes = _objectWithoutPropertiesLoose2(_ref, _excluded$2);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n6) => "-" + n6.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (let name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i5) => {
    instance.setAttribute(name, values[i5]);
  });
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var _excluded$1 = ["x", "y", "z"];
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v5) => isValueIdentity(v5, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_ref) {
    let {
      x: x4,
      y: y3,
      z: z2
    } = _ref, style = _objectWithoutPropertiesLoose2(_ref, _excluded$1);
    const inputs = [];
    const transforms = [];
    if (x4 || y3 || z2) {
      inputs.push([x4 || 0, y3 || 0, z2 || 0]);
      transforms.push((xyz) => [`translate3d(${xyz.map((v5) => addUnit(v5, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x5, y4, z3, deg]) => [`rotate3d(${x5},${y4},${z3},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v5) => addUnit(v5, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this._value = null;
    this.inputs = inputs;
    this.transforms = transforms;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i5) => {
      const arg1 = getFluidValue(input[0]);
      const [t7, id] = this.transforms[i5](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t7;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
var _excluded = ["scrollTop", "scrollLeft"];
globals.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator,
  colors
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_ref) => {
    let props = _objectWithoutPropertiesLoose2(_ref, _excluded);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/line/node_modules/@nivo/scales/dist/nivo-scales.es.js
var import_uniq = __toESM(require_uniq());
var import_uniqBy = __toESM(require_uniqBy());
var import_sortBy = __toESM(require_sortBy());
var import_last = __toESM(require_last());
var import_isDate = __toESM(require_isDate());
function $() {
  return $ = Object.assign || function(n6) {
    for (var t7 = 1; t7 < arguments.length; t7++) {
      var r5 = arguments[t7];
      for (var e7 in r5)
        Object.prototype.hasOwnProperty.call(r5, e7) && (n6[e7] = r5[e7]);
    }
    return n6;
  }, $.apply(this, arguments);
}
var J = [function(n6) {
  return n6.setMilliseconds(0);
}, function(n6) {
  return n6.setSeconds(0);
}, function(n6) {
  return n6.setMinutes(0);
}, function(n6) {
  return n6.setHours(0);
}, function(n6) {
  return n6.setDate(1);
}, function(n6) {
  return n6.setMonth(0);
}];
var K = { millisecond: [], second: J.slice(0, 1), minute: J.slice(0, 2), hour: J.slice(0, 3), day: J.slice(0, 4), month: J.slice(0, 5), year: J.slice(0, 6) };
var L = function(n6) {
  return function(t7) {
    return K[n6].forEach(function(n7) {
      n7(t7);
    }), t7;
  };
};
var Q = function(n6) {
  var t7 = n6.format, r5 = void 0 === t7 ? "native" : t7, e7 = n6.precision, a4 = void 0 === e7 ? "millisecond" : e7, u2 = n6.useUTC, c2 = void 0 === u2 || u2, f4 = L(a4);
  return function(n7) {
    if (void 0 === n7)
      return n7;
    if ("native" === r5 || n7 instanceof Date)
      return f4(n7);
    var t8 = c2 ? utcParse(r5) : timeParse(r5);
    return f4(t8(n7));
  };
};
var W = function(n6, t7, r5, e7) {
  var a4, i5, o4, c2, f4 = n6.min, d2 = void 0 === f4 ? 0 : f4, s3 = n6.max, l3 = void 0 === s3 ? "auto" : s3, m3 = n6.stacked, v5 = void 0 !== m3 && m3, y3 = n6.reverse, p5 = void 0 !== y3 && y3, h3 = n6.clamp, g5 = void 0 !== h3 && h3, x4 = n6.nice, k5 = void 0 !== x4 && x4;
  "auto" === d2 ? a4 = true === v5 ? null != (i5 = t7.minStacked) ? i5 : 0 : t7.min : a4 = d2;
  "auto" === l3 ? o4 = true === v5 ? null != (c2 = t7.maxStacked) ? c2 : 0 : t7.max : o4 = l3;
  var T4 = linear().rangeRound("x" === e7 ? [0, r5] : [r5, 0]).domain(p5 ? [o4, a4] : [a4, o4]).clamp(g5);
  return true === k5 ? T4.nice() : "number" == typeof k5 && T4.nice(k5), X(T4, v5);
};
var X = function(n6, t7) {
  void 0 === t7 && (t7 = false);
  var r5 = n6;
  return r5.type = "linear", r5.stacked = t7, r5;
};
var Y = function(n6, t7, r5) {
  var e7 = point().range([0, r5]).domain(t7.all);
  return e7.type = "point", e7;
};
var _ = function(n6, t7, r5, e7) {
  var a4 = n6.round, i5 = void 0 === a4 || a4, o4 = band().range("x" === e7 ? [0, r5] : [r5, 0]).domain(t7.all).round(i5);
  return nn(o4);
};
var nn = function(n6) {
  var t7 = n6;
  return t7.type = "band", t7;
};
var tn = function(n6, t7, r5) {
  var e7, a4, i5 = n6.format, o4 = void 0 === i5 ? "native" : i5, u2 = n6.precision, c2 = void 0 === u2 ? "millisecond" : u2, f4 = n6.min, l3 = void 0 === f4 ? "auto" : f4, m3 = n6.max, v5 = void 0 === m3 ? "auto" : m3, y3 = n6.useUTC, p5 = void 0 === y3 || y3, h3 = n6.nice, g5 = void 0 !== h3 && h3, x4 = Q({ format: o4, precision: c2, useUTC: p5 });
  e7 = "auto" === l3 ? x4(t7.min) : "native" !== o4 ? x4(l3) : l3, a4 = "auto" === v5 ? x4(t7.max) : "native" !== o4 ? x4(v5) : v5;
  var k5 = p5 ? utcTime() : time();
  k5.range([0, r5]), e7 && a4 && k5.domain([e7, a4]), true === g5 ? k5.nice() : "object" != typeof g5 && "number" != typeof g5 || k5.nice(g5);
  var T4 = k5;
  return T4.type = "time", T4.useUTC = p5, T4;
};
var rn2 = function(n6, t7, r5, e7) {
  var a4, i5 = n6.base, o4 = void 0 === i5 ? 10 : i5, u2 = n6.min, c2 = void 0 === u2 ? "auto" : u2, f4 = n6.max, d2 = void 0 === f4 ? "auto" : f4;
  if (t7.all.some(function(n7) {
    return 0 === n7;
  }))
    throw new Error("a log scale domain must not include or cross zero");
  var s3, m3, v5 = false;
  if (t7.all.filter(function(n7) {
    return null != n7;
  }).forEach(function(n7) {
    v5 || (void 0 === a4 ? a4 = Math.sign(n7) : Math.sign(n7) !== a4 && (v5 = true));
  }), v5)
    throw new Error("a log scale domain must be strictly-positive or strictly-negative");
  s3 = "auto" === c2 ? t7.min : c2, m3 = "auto" === d2 ? t7.max : d2;
  var y3 = log().domain([s3, m3]).rangeRound("x" === e7 ? [0, r5] : [r5, 0]).base(o4).nice();
  return y3.type = "log", y3;
};
var en = function(n6, t7, r5, e7) {
  var a4, i5, o4 = n6.constant, u2 = void 0 === o4 ? 1 : o4, c2 = n6.min, f4 = void 0 === c2 ? "auto" : c2, d2 = n6.max, s3 = void 0 === d2 ? "auto" : d2, l3 = n6.reverse, v5 = void 0 !== l3 && l3;
  a4 = "auto" === f4 ? t7.min : f4, i5 = "auto" === s3 ? t7.max : s3;
  var y3 = symlog().constant(u2).rangeRound("x" === e7 ? [0, r5] : [r5, 0]).nice();
  true === v5 ? y3.domain([i5, a4]) : y3.domain([a4, i5]);
  var p5 = y3;
  return p5.type = "symlog", p5;
};
var an = function(n6) {
  return "x" === n6 ? "y" : "x";
};
var on = function(n6, t7) {
  return n6 === t7;
};
var un = function(n6, t7) {
  return n6.getTime() === t7.getTime();
};
function cn(n6, t7, r5, e7) {
  switch (n6.type) {
    case "linear":
      return W(n6, t7, r5, e7);
    case "point":
      return Y(0, t7, r5);
    case "band":
      return _(n6, t7, r5, e7);
    case "time":
      return tn(n6, t7, r5);
    case "log":
      return rn2(n6, t7, r5, e7);
    case "symlog":
      return en(n6, t7, r5, e7);
    default:
      throw new Error("invalid scale spec");
  }
}
var fn = function(n6, t7, r5) {
  var e7;
  if ("stacked" in r5 && r5.stacked) {
    var a4 = n6.data["x" === t7 ? "xStacked" : "yStacked"];
    return null == a4 ? null : r5(a4);
  }
  return null != (e7 = r5(n6.data[t7])) ? e7 : null;
};
var dn = function(n6, t7, r5, e7, a4) {
  var i5 = n6.map(function(n7) {
    return function(n8) {
      return $({}, n8, { data: n8.data.map(function(n9) {
        return { data: $({}, n9) };
      }) });
    }(n7);
  }), o4 = sn(i5, t7, r5);
  "stacked" in t7 && true === t7.stacked && vn(o4, i5), "stacked" in r5 && true === r5.stacked && yn(o4, i5);
  var u2 = cn(t7, o4.x, e7, "x"), c2 = cn(r5, o4.y, a4, "y"), f4 = i5.map(function(n7) {
    return $({}, n7, { data: n7.data.map(function(n8) {
      return $({}, n8, { position: { x: fn(n8, "x", u2), y: fn(n8, "y", c2) } });
    }) });
  });
  return $({}, o4, { series: f4, xScale: u2, yScale: c2 });
};
var sn = function(n6, t7, r5) {
  return { x: ln(n6, "x", t7), y: ln(n6, "y", r5) };
};
var ln = function(a4, i5, o4, u2) {
  var c2 = void 0 === u2 ? {} : u2, f4 = c2.getValue, d2 = void 0 === f4 ? function(n6) {
    return n6.data[i5];
  } : f4, s3 = c2.setValue, l3 = void 0 === s3 ? function(n6, t7) {
    n6.data[i5] = t7;
  } : s3;
  if ("linear" === o4.type)
    a4.forEach(function(n6) {
      n6.data.forEach(function(n7) {
        var t7 = d2(n7);
        t7 && l3(n7, parseFloat(String(t7)));
      });
    });
  else if ("time" === o4.type && "native" !== o4.format) {
    var m3 = Q(o4);
    a4.forEach(function(n6) {
      n6.data.forEach(function(n7) {
        var t7 = d2(n7);
        t7 && l3(n7, m3(t7));
      });
    });
  }
  var v5 = [];
  switch (a4.forEach(function(n6) {
    n6.data.forEach(function(n7) {
      v5.push(d2(n7));
    });
  }), o4.type) {
    case "linear":
      var y3 = (0, import_sortBy.default)((0, import_uniq.default)(v5).filter(function(n6) {
        return null !== n6;
      }), function(n6) {
        return n6;
      });
      return { all: y3, min: Math.min.apply(Math, y3), max: Math.max.apply(Math, y3) };
    case "time":
      var p5 = (0, import_uniqBy.default)(v5, function(n6) {
        return n6.getTime();
      }).slice(0).sort(function(n6, t7) {
        return t7.getTime() - n6.getTime();
      }).reverse();
      return { all: p5, min: p5[0], max: (0, import_last.default)(p5) };
    default:
      var h3 = (0, import_uniq.default)(v5);
      return { all: h3, min: h3[0], max: (0, import_last.default)(h3) };
  }
};
var mn = function(n6, t7, r5) {
  var i5 = an(n6), o4 = [];
  t7[i5].all.forEach(function(t8) {
    var u2 = (0, import_isDate.default)(t8) ? un : on, c2 = [];
    r5.forEach(function(r6) {
      var a4 = r6.data.find(function(n7) {
        return u2(n7.data[i5], t8);
      }), f4 = null, d2 = null;
      if (void 0 !== a4) {
        if (null !== (f4 = a4.data[n6])) {
          var s3 = (0, import_last.default)(c2);
          void 0 === s3 ? d2 = f4 : null !== s3 && (d2 = s3 + f4);
        }
        a4.data["x" === n6 ? "xStacked" : "yStacked"] = d2;
      }
      c2.push(d2), null !== d2 && o4.push(d2);
    });
  }), t7[n6].minStacked = Math.min.apply(Math, o4), t7[n6].maxStacked = Math.max.apply(Math, o4);
};
var vn = function(n6, t7) {
  return mn("x", n6, t7);
};
var yn = function(n6, t7) {
  return mn("y", n6, t7);
};
var pn = function(n6) {
  var t7 = n6.bandwidth();
  if (0 === t7)
    return n6;
  var r5 = t7 / 2;
  return n6.round() && (r5 = Math.round(r5)), function(t8) {
    var e7;
    return (null != (e7 = n6(t8)) ? e7 : 0) + r5;
  };
};
var hn = { millisecond: [millisecond_default, millisecond_default], second: [second_default, second_default], minute: [minute_default, utcMinute_default], hour: [hour_default, utcHour_default], day: [newInterval(function(n6) {
  return n6.setHours(0, 0, 0, 0);
}, function(n6, t7) {
  return n6.setDate(n6.getDate() + t7);
}, function(n6, t7) {
  return (t7.getTime() - n6.getTime()) / 864e5;
}, function(n6) {
  return Math.floor(n6.getTime() / 864e5);
}), newInterval(function(n6) {
  return n6.setUTCHours(0, 0, 0, 0);
}, function(n6, t7) {
  return n6.setUTCDate(n6.getUTCDate() + t7);
}, function(n6, t7) {
  return (t7.getTime() - n6.getTime()) / 864e5;
}, function(n6) {
  return Math.floor(n6.getTime() / 864e5);
})], week: [sunday, utcSunday], sunday: [sunday, utcSunday], monday: [monday, utcMonday], tuesday: [tuesday, utcTuesday], wednesday: [wednesday, utcWednesday], thursday: [thursday, utcThursday], friday: [friday, utcFriday], saturday: [saturday, utcSaturday], month: [month_default, utcMonth_default], year: [year_default, utcYear_default] };
var gn = Object.keys(hn);
var xn = new RegExp("^every\\s*(\\d+)?\\s*(" + gn.join("|") + ")s?$", "i");
var kn = function(n6, t7) {
  if (Array.isArray(t7))
    return t7;
  if ("string" == typeof t7 && "useUTC" in n6) {
    var r5 = t7.match(xn);
    if (r5) {
      var e7 = r5[1], a4 = r5[2], i5 = hn[a4][n6.useUTC ? 1 : 0];
      if ("day" === a4) {
        var o4, u2, c2 = n6.domain(), f4 = c2[0], d2 = c2[1], s3 = new Date(d2);
        return s3.setDate(s3.getDate() + 1), null != (o4 = null == (u2 = i5.every(Number(null != e7 ? e7 : 1))) ? void 0 : u2.range(f4, s3)) ? o4 : [];
      }
      if (void 0 === e7)
        return n6.ticks(i5);
      var l3 = i5.every(Number(e7));
      if (l3)
        return n6.ticks(l3);
    }
    throw new Error("Invalid tickValues: " + t7);
  }
  if ("ticks" in n6) {
    if (void 0 === t7)
      return n6.ticks();
    if ("number" == typeof (m3 = t7) && isFinite(m3) && Math.floor(m3) === m3)
      return n6.ticks(t7);
  }
  var m3;
  return n6.domain();
};

// node_modules/@nivo/line/node_modules/@nivo/axes/dist/nivo-axes.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_prop_types2 = __toESM(require_prop_types());
function v() {
  return v = Object.assign || function(t7) {
    for (var e7 = 1; e7 < arguments.length; e7++) {
      var i5 = arguments[e7];
      for (var n6 in i5)
        Object.prototype.hasOwnProperty.call(i5, n6) && (t7[n6] = i5[n6]);
    }
    return t7;
  }, v.apply(this, arguments);
}
var p = function(t7) {
  var e7, i5 = t7.axis, n6 = t7.scale, r5 = t7.ticksPosition, a4 = t7.tickValues, o4 = t7.tickSize, s3 = t7.tickPadding, c2 = t7.tickRotation, f4 = t7.engine, x4 = void 0 === f4 ? "svg" : f4, d2 = kn(n6, a4), y3 = yi[x4], g5 = "bandwidth" in n6 ? pn(n6) : n6, k5 = { lineX: 0, lineY: 0 }, h3 = { textX: 0, textY: 0 }, p5 = "object" == typeof document && "rtl" === document.dir, b5 = y3.align.center, P4 = y3.baseline.center;
  return "x" === i5 ? (e7 = function(t8) {
    var e8;
    return { x: null != (e8 = g5(t8)) ? e8 : 0, y: 0 };
  }, k5.lineY = o4 * ("after" === r5 ? 1 : -1), h3.textY = (o4 + s3) * ("after" === r5 ? 1 : -1), P4 = "after" === r5 ? y3.baseline.top : y3.baseline.bottom, 0 === c2 ? b5 = y3.align.center : "after" === r5 && c2 < 0 || "before" === r5 && c2 > 0 ? (b5 = y3.align[p5 ? "left" : "right"], P4 = y3.baseline.center) : ("after" === r5 && c2 > 0 || "before" === r5 && c2 < 0) && (b5 = y3.align[p5 ? "right" : "left"], P4 = y3.baseline.center)) : (e7 = function(t8) {
    var e8;
    return { x: 0, y: null != (e8 = g5(t8)) ? e8 : 0 };
  }, k5.lineX = o4 * ("after" === r5 ? 1 : -1), h3.textX = (o4 + s3) * ("after" === r5 ? 1 : -1), b5 = "after" === r5 ? y3.align.left : y3.align.right), { ticks: d2.map(function(t8) {
    return v({ key: "number" == typeof t8 || "string" == typeof t8 ? t8 : "" + t8, value: t8 }, e7(t8), k5, h3);
  }), textAlign: b5, textBaseline: P4 };
};
var b = function(t7, e7) {
  if (void 0 === t7 || "function" == typeof t7)
    return t7;
  if ("time" === e7.type) {
    var i5 = timeFormat(t7);
    return function(t8) {
      return i5(t8 instanceof Date ? t8 : new Date(t8));
    };
  }
  return format(t7);
};
var P = function(t7) {
  var e7, i5 = t7.width, n6 = t7.height, r5 = t7.scale, a4 = t7.axis, o4 = t7.values, l3 = (e7 = o4, Array.isArray(e7) ? o4 : void 0) || kn(r5, o4), s3 = "bandwidth" in r5 ? pn(r5) : r5, c2 = "x" === a4 ? l3.map(function(t8) {
    var e8, i6;
    return { key: "" + t8, x1: null != (e8 = s3(t8)) ? e8 : 0, x2: null != (i6 = s3(t8)) ? i6 : 0, y1: 0, y2: n6 };
  }) : l3.map(function(t8) {
    var e8, n7;
    return { key: "" + t8, x1: 0, x2: i5, y1: null != (e8 = s3(t8)) ? e8 : 0, y2: null != (n7 = s3(t8)) ? n7 : 0 };
  });
  return c2;
};
var S = (0, import_react5.memo)(function(t7) {
  var e7, n6 = t7.value, a4 = t7.format, o4 = t7.lineX, l3 = t7.lineY, c2 = t7.onClick, f4 = t7.textBaseline, x4 = t7.textAnchor, d2 = t7.animatedProps, u2 = Vt(), m3 = null != (e7 = null == a4 ? void 0 : a4(n6)) ? e7 : n6, k5 = (0, import_react5.useMemo)(function() {
    var t8 = { opacity: d2.opacity };
    return c2 ? { style: v({}, t8, { cursor: "pointer" }), onClick: function(t9) {
      return c2(t9, m3);
    } } : { style: t8 };
  }, [d2.opacity, c2, m3]);
  return (0, import_jsx_runtime.jsxs)(animated.g, v({ transform: d2.transform }, k5, { children: [(0, import_jsx_runtime.jsx)("line", { x1: 0, x2: o4, y1: 0, y2: l3, style: u2.axis.ticks.line }), (0, import_jsx_runtime.jsx)(animated.text, { dominantBaseline: f4, textAnchor: x4, transform: d2.textTransform, style: u2.axis.ticks.text, children: m3 })] }));
});
var T = (0, import_react5.memo)(function(e7) {
  var n6 = e7.axis, l3 = e7.scale, f4 = e7.x, x4 = void 0 === f4 ? 0 : f4, d2 = e7.y, u2 = void 0 === d2 ? 0 : d2, m3 = e7.length, k5 = e7.ticksPosition, h3 = e7.tickValues, P4 = e7.tickSize, T4 = void 0 === P4 ? 5 : P4, w4 = e7.tickPadding, A2 = void 0 === w4 ? 5 : w4, O4 = e7.tickRotation, X4 = void 0 === O4 ? 0 : O4, Y4 = e7.format, W3 = e7.renderTick, B3 = void 0 === W3 ? S : W3, z2 = e7.legend, V3 = e7.legendPosition, C3 = void 0 === V3 ? "end" : V3, R = e7.legendOffset, j2 = void 0 === R ? 0 : R, E2 = e7.onClick, D = e7.ariaHidden, q = Vt(), F = (0, import_react5.useMemo)(function() {
    return b(Y4, l3);
  }, [Y4, l3]), H2 = p({ axis: n6, scale: l3, ticksPosition: k5, tickValues: h3, tickSize: T4, tickPadding: A2, tickRotation: X4 }), N3 = H2.ticks, I = H2.textAlign, G = H2.textBaseline, J2 = null;
  if (void 0 !== z2) {
    var K3, L2 = 0, M = 0, Q3 = 0;
    "y" === n6 ? (Q3 = -90, L2 = j2, "start" === C3 ? (K3 = "start", M = m3) : "middle" === C3 ? (K3 = "middle", M = m3 / 2) : "end" === C3 && (K3 = "end")) : (M = j2, "start" === C3 ? K3 = "start" : "middle" === C3 ? (K3 = "middle", L2 = m3 / 2) : "end" === C3 && (K3 = "end", L2 = m3)), J2 = (0, import_jsx_runtime.jsx)("text", { transform: "translate(" + L2 + ", " + M + ") rotate(" + Q3 + ")", textAnchor: K3, style: v({ dominantBaseline: "central" }, q.axis.legend.text), children: z2 });
  }
  var U = tt(), Z = U.animate, $2 = U.config, _2 = useSpring({ transform: "translate(" + x4 + "," + u2 + ")", lineX2: "x" === n6 ? m3 : 0, lineY2: "x" === n6 ? 0 : m3, config: $2, immediate: !Z }), tt2 = useTransition(N3, { keys: function(t7) {
    return t7.key;
  }, initial: function(t7) {
    return { opacity: 1, transform: "translate(" + t7.x + "," + t7.y + ")", textTransform: "translate(" + t7.textX + "," + t7.textY + ") rotate(" + X4 + ")" };
  }, from: function(t7) {
    return { opacity: 0, transform: "translate(" + t7.x + "," + t7.y + ")", textTransform: "translate(" + t7.textX + "," + t7.textY + ") rotate(" + X4 + ")" };
  }, enter: function(t7) {
    return { opacity: 1, transform: "translate(" + t7.x + "," + t7.y + ")", textTransform: "translate(" + t7.textX + "," + t7.textY + ") rotate(" + X4 + ")" };
  }, update: function(t7) {
    return { opacity: 1, transform: "translate(" + t7.x + "," + t7.y + ")", textTransform: "translate(" + t7.textX + "," + t7.textY + ") rotate(" + X4 + ")" };
  }, leave: { opacity: 0 }, config: $2, immediate: !Z });
  return (0, import_jsx_runtime.jsxs)(animated.g, { transform: _2.transform, "aria-hidden": D, children: [tt2(function(e8, i5, n7, r5) {
    return t2.createElement(B3, v({ tickIndex: r5, format: F, rotate: X4, textBaseline: G, textAnchor: I, animatedProps: e8 }, i5, E2 ? { onClick: E2 } : {}));
  }), (0, import_jsx_runtime.jsx)(animated.line, { style: q.axis.domain.line, x1: 0, x2: _2.lineX2, y1: 0, y2: _2.lineY2 }), J2] });
});
var w = { ticksPosition: import_prop_types2.default.oneOf(["before", "after"]), tickValues: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string, import_prop_types2.default.instanceOf(Date)])), import_prop_types2.default.string]), tickSize: import_prop_types2.default.number, tickPadding: import_prop_types2.default.number, tickRotation: import_prop_types2.default.number, format: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.string]), renderTick: import_prop_types2.default.func, legend: import_prop_types2.default.node, legendPosition: import_prop_types2.default.oneOf(["start", "middle", "end"]), legendOffset: import_prop_types2.default.number, ariaHidden: import_prop_types2.default.bool };
var A = import_prop_types2.default.shape(w);
var O = ["top", "right", "bottom", "left"];
var X2 = (0, import_react5.memo)(function(t7) {
  var e7 = t7.xScale, i5 = t7.yScale, n6 = t7.width, r5 = t7.height, a4 = { top: t7.top, right: t7.right, bottom: t7.bottom, left: t7.left };
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: O.map(function(t8) {
    var o4 = a4[t8];
    if (!o4)
      return null;
    var l3 = "top" === t8 || "bottom" === t8;
    return (0, import_jsx_runtime.jsx)(T, v({}, o4, { axis: l3 ? "x" : "y", x: "right" === t8 ? n6 : 0, y: "bottom" === t8 ? r5 : 0, scale: l3 ? e7 : i5, length: l3 ? n6 : r5, ticksPosition: "top" === t8 || "left" === t8 ? "before" : "after" }), t8);
  }) });
});
var Y2 = (0, import_react5.memo)(function(t7) {
  var e7 = t7.animatedProps, i5 = Vt();
  return (0, import_jsx_runtime.jsx)(animated.line, v({}, e7, i5.grid.line));
});
var W2 = (0, import_react5.memo)(function(t7) {
  var e7 = t7.lines, i5 = tt(), r5 = i5.animate, a4 = i5.config, l3 = useTransition(e7, { keys: function(t8) {
    return t8.key;
  }, initial: function(t8) {
    return { opacity: 1, x1: t8.x1, x2: t8.x2, y1: t8.y1, y2: t8.y2 };
  }, from: function(t8) {
    return { opacity: 0, x1: t8.x1, x2: t8.x2, y1: t8.y1, y2: t8.y2 };
  }, enter: function(t8) {
    return { opacity: 1, x1: t8.x1, x2: t8.x2, y1: t8.y1, y2: t8.y2 };
  }, update: function(t8) {
    return { opacity: 1, x1: t8.x1, x2: t8.x2, y1: t8.y1, y2: t8.y2 };
  }, leave: { opacity: 0 }, config: a4, immediate: !r5 });
  return (0, import_jsx_runtime.jsx)("g", { children: l3(function(t8, e8) {
    return (0, import_react5.createElement)(Y2, v({}, e8, { key: e8.key, animatedProps: t8 }));
  }) });
});
var B = (0, import_react5.memo)(function(t7) {
  var e7 = t7.width, n6 = t7.height, r5 = t7.xScale, a4 = t7.yScale, o4 = t7.xValues, l3 = t7.yValues, s3 = (0, import_react5.useMemo)(function() {
    return !!r5 && P({ width: e7, height: n6, scale: r5, axis: "x", values: o4 });
  }, [r5, o4, e7, n6]), c2 = (0, import_react5.useMemo)(function() {
    return !!a4 && P({ width: e7, height: n6, scale: a4, axis: "y", values: l3 });
  }, [n6, e7, a4, l3]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [s3 && (0, import_jsx_runtime.jsx)(W2, { lines: s3 }), c2 && (0, import_jsx_runtime.jsx)(W2, { lines: c2 })] });
});
var z = function(t7, e7) {
  var i5, n6 = e7.axis, r5 = e7.scale, a4 = e7.x, o4 = void 0 === a4 ? 0 : a4, l3 = e7.y, s3 = void 0 === l3 ? 0 : l3, c2 = e7.length, x4 = e7.ticksPosition, d2 = e7.tickValues, u2 = e7.tickSize, m3 = void 0 === u2 ? 5 : u2, y3 = e7.tickPadding, g5 = void 0 === y3 ? 5 : y3, k5 = e7.tickRotation, h3 = void 0 === k5 ? 0 : k5, v5 = e7.format, b5 = e7.legend, P4 = e7.legendPosition, S4 = void 0 === P4 ? "end" : P4, T4 = e7.legendOffset, w4 = void 0 === T4 ? 0 : T4, A2 = e7.theme, O4 = p({ axis: n6, scale: r5, ticksPosition: x4, tickValues: d2, tickSize: m3, tickPadding: g5, tickRotation: h3, engine: "canvas" }), X4 = O4.ticks, Y4 = O4.textAlign, W3 = O4.textBaseline;
  t7.save(), t7.translate(o4, s3), t7.textAlign = Y4, t7.textBaseline = W3, t7.font = (A2.axis.ticks.text.fontWeight ? A2.axis.ticks.text.fontWeight + " " : "") + A2.axis.ticks.text.fontSize + "px " + A2.axis.ticks.text.fontFamily, (null != (i5 = A2.axis.domain.line.strokeWidth) ? i5 : 0) > 0 && (t7.lineWidth = Number(A2.axis.domain.line.strokeWidth), t7.lineCap = "square", A2.axis.domain.line.stroke && (t7.strokeStyle = A2.axis.domain.line.stroke), t7.beginPath(), t7.moveTo(0, 0), t7.lineTo("x" === n6 ? c2 : 0, "x" === n6 ? 0 : c2), t7.stroke());
  var B3 = "function" == typeof v5 ? v5 : function(t8) {
    return "" + t8;
  };
  if (X4.forEach(function(e8) {
    var i6;
    (null != (i6 = A2.axis.ticks.line.strokeWidth) ? i6 : 0) > 0 && (t7.lineWidth = Number(A2.axis.ticks.line.strokeWidth), t7.lineCap = "square", A2.axis.ticks.line.stroke && (t7.strokeStyle = A2.axis.ticks.line.stroke), t7.beginPath(), t7.moveTo(e8.x, e8.y), t7.lineTo(e8.x + e8.lineX, e8.y + e8.lineY), t7.stroke());
    var n7 = B3(e8.value);
    t7.save(), t7.translate(e8.x + e8.textX, e8.y + e8.textY), t7.rotate(ui(h3)), A2.axis.ticks.text.fill && (t7.fillStyle = A2.axis.ticks.text.fill), t7.fillText(String(n7), 0, 0), t7.restore();
  }), void 0 !== b5) {
    var z2 = 0, V3 = 0, C3 = 0, R = "center";
    "y" === n6 ? (C3 = -90, z2 = w4, "start" === S4 ? (R = "start", V3 = c2) : "middle" === S4 ? (R = "center", V3 = c2 / 2) : "end" === S4 && (R = "end")) : (V3 = w4, "start" === S4 ? R = "start" : "middle" === S4 ? (R = "center", z2 = c2 / 2) : "end" === S4 && (R = "end", z2 = c2)), t7.translate(z2, V3), t7.rotate(ui(C3)), t7.font = (A2.axis.legend.text.fontWeight ? A2.axis.legend.text.fontWeight + " " : "") + A2.axis.legend.text.fontSize + "px " + A2.axis.legend.text.fontFamily, A2.axis.legend.text.fill && (t7.fillStyle = A2.axis.legend.text.fill), t7.textAlign = R, t7.textBaseline = "middle", t7.fillText(b5, 0, 0);
  }
  t7.restore();
};
var V = function(t7, e7) {
  var i5 = e7.xScale, n6 = e7.yScale, r5 = e7.width, a4 = e7.height, o4 = e7.top, l3 = e7.right, s3 = e7.bottom, c2 = e7.left, f4 = e7.theme, x4 = { top: o4, right: l3, bottom: s3, left: c2 };
  O.forEach(function(e8) {
    var o5 = x4[e8];
    if (!o5)
      return null;
    var l4 = "top" === e8 || "bottom" === e8, s4 = "top" === e8 || "left" === e8 ? "before" : "after", c3 = l4 ? i5 : n6, d2 = b(o5.format, c3);
    z(t7, v({}, o5, { axis: l4 ? "x" : "y", x: "right" === e8 ? r5 : 0, y: "bottom" === e8 ? a4 : 0, scale: c3, format: d2, length: l4 ? r5 : a4, ticksPosition: s4, theme: f4 }));
  });
};
var C = function(t7, e7) {
  var i5 = e7.width, n6 = e7.height, r5 = e7.scale, a4 = e7.axis, o4 = e7.values;
  P({ width: i5, height: n6, scale: r5, axis: a4, values: o4 }).forEach(function(e8) {
    t7.beginPath(), t7.moveTo(e8.x1, e8.y1), t7.lineTo(e8.x2, e8.y2), t7.stroke();
  });
};

// node_modules/@nivo/line/node_modules/@nivo/legends/dist/nivo-legends.es.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var a2 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
var m = function(e7) {
  var i5 = e7.x, n6 = e7.y, o4 = e7.size, r5 = e7.fill, l3 = e7.opacity, a4 = void 0 === l3 ? 1 : l3, c2 = e7.borderWidth, s3 = void 0 === c2 ? 0 : c2, d2 = e7.borderColor;
  return (0, import_jsx_runtime2.jsx)("circle", { r: o4 / 2, cx: i5 + o4 / 2, cy: n6 + o4 / 2, fill: r5, opacity: a4, strokeWidth: s3, stroke: void 0 === d2 ? "transparent" : d2, style: { pointerEvents: "none" } });
};
var f = function(e7) {
  var i5 = e7.x, n6 = e7.y, o4 = e7.size, r5 = e7.fill, l3 = e7.opacity, a4 = void 0 === l3 ? 1 : l3, c2 = e7.borderWidth, s3 = void 0 === c2 ? 0 : c2, d2 = e7.borderColor;
  return (0, import_jsx_runtime2.jsx)("g", { transform: "translate(" + i5 + "," + n6 + ")", children: (0, import_jsx_runtime2.jsx)("path", { d: "\n                    M" + o4 / 2 + " 0\n                    L" + 0.8 * o4 + " " + o4 / 2 + "\n                    L" + o4 / 2 + " " + o4 + "\n                    L" + 0.2 * o4 + " " + o4 / 2 + "\n                    L" + o4 / 2 + " 0\n                ", fill: r5, opacity: a4, strokeWidth: s3, stroke: void 0 === d2 ? "transparent" : d2, style: { pointerEvents: "none" } }) });
};
var u = function(e7) {
  var i5 = e7.x, n6 = e7.y, o4 = e7.size, r5 = e7.fill, l3 = e7.opacity, a4 = void 0 === l3 ? 1 : l3, c2 = e7.borderWidth, s3 = void 0 === c2 ? 0 : c2, d2 = e7.borderColor;
  return (0, import_jsx_runtime2.jsx)("rect", { x: i5, y: n6, fill: r5, opacity: a4, strokeWidth: s3, stroke: void 0 === d2 ? "transparent" : d2, width: o4, height: o4, style: { pointerEvents: "none" } });
};
var v2 = function(e7) {
  var i5 = e7.x, n6 = e7.y, o4 = e7.size, r5 = e7.fill, l3 = e7.opacity, a4 = void 0 === l3 ? 1 : l3, c2 = e7.borderWidth, s3 = void 0 === c2 ? 0 : c2, d2 = e7.borderColor;
  return (0, import_jsx_runtime2.jsx)("g", { transform: "translate(" + i5 + "," + n6 + ")", children: (0, import_jsx_runtime2.jsx)("path", { d: "\n                M" + o4 / 2 + " 0\n                L" + o4 + " " + o4 + "\n                L0 " + o4 + "\n                L" + o4 / 2 + " 0\n            ", fill: r5, opacity: a4, strokeWidth: s3, stroke: void 0 === d2 ? "transparent" : d2, style: { pointerEvents: "none" } }) });
};
function p2() {
  return p2 = Object.assign || function(t7) {
    for (var e7 = 1; e7 < arguments.length; e7++) {
      var i5 = arguments[e7];
      for (var n6 in i5)
        Object.prototype.hasOwnProperty.call(i5, n6) && (t7[n6] = i5[n6]);
    }
    return t7;
  }, p2.apply(this, arguments);
}
var b2 = { top: 0, right: 0, bottom: 0, left: 0 };
var k2 = function(t7) {
  var e7, i5 = t7.direction, n6 = t7.itemsSpacing, o4 = t7.padding, r5 = t7.itemCount, l3 = t7.itemWidth, a4 = t7.itemHeight;
  if ("number" != typeof o4 && ("object" != typeof (e7 = o4) || Array.isArray(e7) || null === e7))
    throw new Error("Invalid property padding, must be one of: number, object");
  var c2 = "number" == typeof o4 ? { top: o4, right: o4, bottom: o4, left: o4 } : p2({}, b2, o4), s3 = c2.left + c2.right, d2 = c2.top + c2.bottom, h3 = l3 + s3, g5 = a4 + d2, m3 = (r5 - 1) * n6;
  return "row" === i5 ? h3 = l3 * r5 + m3 + s3 : "column" === i5 && (g5 = a4 * r5 + m3 + d2), { width: h3, height: g5, padding: c2 };
};
var x = function(t7) {
  var e7 = t7.anchor, i5 = t7.translateX, n6 = t7.translateY, o4 = t7.containerWidth, r5 = t7.containerHeight, l3 = t7.width, a4 = t7.height, c2 = i5, s3 = n6;
  switch (e7) {
    case "top":
      c2 += (o4 - l3) / 2;
      break;
    case "top-right":
      c2 += o4 - l3;
      break;
    case "right":
      c2 += o4 - l3, s3 += (r5 - a4) / 2;
      break;
    case "bottom-right":
      c2 += o4 - l3, s3 += r5 - a4;
      break;
    case "bottom":
      c2 += (o4 - l3) / 2, s3 += r5 - a4;
      break;
    case "bottom-left":
      s3 += r5 - a4;
      break;
    case "left":
      s3 += (r5 - a4) / 2;
      break;
    case "center":
      c2 += (o4 - l3) / 2, s3 += (r5 - a4) / 2;
  }
  return { x: c2, y: s3 };
};
var S2 = function(t7) {
  var e7, i5, n6, o4, r5, l3, a4 = t7.direction, c2 = t7.justify, s3 = t7.symbolSize, d2 = t7.symbolSpacing, h3 = t7.width, g5 = t7.height;
  switch (a4) {
    case "left-to-right":
      e7 = 0, i5 = (g5 - s3) / 2, o4 = g5 / 2, l3 = "central", c2 ? (n6 = h3, r5 = "end") : (n6 = s3 + d2, r5 = "start");
      break;
    case "right-to-left":
      e7 = h3 - s3, i5 = (g5 - s3) / 2, o4 = g5 / 2, l3 = "central", c2 ? (n6 = 0, r5 = "start") : (n6 = h3 - s3 - d2, r5 = "end");
      break;
    case "top-to-bottom":
      e7 = (h3 - s3) / 2, i5 = 0, n6 = h3 / 2, r5 = "middle", c2 ? (o4 = g5, l3 = "alphabetic") : (o4 = s3 + d2, l3 = "text-before-edge");
      break;
    case "bottom-to-top":
      e7 = (h3 - s3) / 2, i5 = g5 - s3, n6 = h3 / 2, r5 = "middle", c2 ? (o4 = 0, l3 = "text-before-edge") : (o4 = g5 - s3 - d2, l3 = "alphabetic");
  }
  return { symbolX: e7, symbolY: i5, labelX: n6, labelY: o4, labelAnchor: r5, labelAlignment: l3 };
};
var O2 = { circle: m, diamond: f, square: u, triangle: v2 };
var B2 = function(i5) {
  var n6, r5, l3, c2, h3, g5, m3, f4, u2, v5, y3, b5 = i5.x, k5 = i5.y, x4 = i5.width, A2 = i5.height, W3 = i5.data, z2 = i5.direction, C3 = void 0 === z2 ? "left-to-right" : z2, B3 = i5.justify, w4 = void 0 !== B3 && B3, X4 = i5.textColor, Y4 = i5.background, H2 = void 0 === Y4 ? "transparent" : Y4, E2 = i5.opacity, j2 = void 0 === E2 ? 1 : E2, T4 = i5.symbolShape, L2 = void 0 === T4 ? "square" : T4, M = i5.symbolSize, F = void 0 === M ? 16 : M, P4 = i5.symbolSpacing, R = void 0 === P4 ? 8 : P4, q = i5.symbolBorderWidth, V3 = void 0 === q ? 0 : q, D = i5.symbolBorderColor, G = void 0 === D ? "transparent" : D, I = i5.onClick, N3 = i5.onMouseEnter, _2 = i5.onMouseLeave, J2 = i5.toggleSerie, K3 = i5.effects, Q3 = (0, import_react6.useState)({}), U = Q3[0], Z = Q3[1], $2 = Vt(), tt2 = (0, import_react6.useCallback)(function(t7) {
    if (K3) {
      var e7 = K3.filter(function(t8) {
        return "hover" === t8.on;
      }).reduce(function(t8, e8) {
        return p2({}, t8, e8.style);
      }, {});
      Z(e7);
    }
    null == N3 || N3(W3, t7);
  }, [N3, W3, K3]), et2 = (0, import_react6.useCallback)(function(t7) {
    if (K3) {
      var e7 = K3.filter(function(t8) {
        return "hover" !== t8.on;
      }).reduce(function(t8, e8) {
        return p2({}, t8, e8.style);
      }, {});
      Z(e7);
    }
    null == _2 || _2(W3, t7);
  }, [_2, W3, K3]), it2 = S2({ direction: C3, justify: w4, symbolSize: null != (n6 = U.symbolSize) ? n6 : F, symbolSpacing: R, width: x4, height: A2 }), nt = it2.symbolX, ot = it2.symbolY, rt = it2.labelX, lt = it2.labelY, at = it2.labelAnchor, ct = it2.labelAlignment, st = [I, N3, _2, J2].some(function(t7) {
    return void 0 !== t7;
  }), dt = "function" == typeof L2 ? L2 : O2[L2];
  return (0, import_jsx_runtime2.jsxs)("g", { transform: "translate(" + b5 + "," + k5 + ")", style: { opacity: null != (r5 = U.itemOpacity) ? r5 : j2 }, children: [(0, import_jsx_runtime2.jsx)("rect", { width: x4, height: A2, fill: null != (l3 = U.itemBackground) ? l3 : H2, style: { cursor: st ? "pointer" : "auto" }, onClick: function(t7) {
    null == I || I(W3, t7), null == J2 || J2(W3.id);
  }, onMouseEnter: tt2, onMouseLeave: et2 }), a2.createElement(dt, p2({ id: W3.id, x: nt, y: ot, size: null != (c2 = U.symbolSize) ? c2 : F, fill: null != (h3 = null != (g5 = W3.fill) ? g5 : W3.color) ? h3 : "black", borderWidth: null != (m3 = U.symbolBorderWidth) ? m3 : V3, borderColor: null != (f4 = U.symbolBorderColor) ? f4 : G }, W3.hidden ? $2.legends.hidden.symbol : void 0)), (0, import_jsx_runtime2.jsx)("text", { textAnchor: at, style: p2({}, $2.legends.text, { fill: null != (u2 = null != (v5 = null != (y3 = U.itemTextColor) ? y3 : X4) ? v5 : $2.legends.text.fill) ? u2 : "black", dominantBaseline: ct, pointerEvents: "none", userSelect: "none" }, W3.hidden ? $2.legends.hidden.text : void 0), x: rt, y: lt, children: W3.label })] });
};
var w2 = function(e7) {
  var i5 = e7.data, n6 = e7.x, o4 = e7.y, r5 = e7.direction, l3 = e7.padding, a4 = void 0 === l3 ? 0 : l3, c2 = e7.justify, s3 = e7.effects, d2 = e7.itemWidth, h3 = e7.itemHeight, g5 = e7.itemDirection, m3 = void 0 === g5 ? "left-to-right" : g5, f4 = e7.itemsSpacing, u2 = void 0 === f4 ? 0 : f4, v5 = e7.itemTextColor, p5 = e7.itemBackground, y3 = void 0 === p5 ? "transparent" : p5, b5 = e7.itemOpacity, x4 = void 0 === b5 ? 1 : b5, S4 = e7.symbolShape, A2 = e7.symbolSize, W3 = e7.symbolSpacing, z2 = e7.symbolBorderWidth, C3 = e7.symbolBorderColor, O4 = e7.onClick, w4 = e7.onMouseEnter, X4 = e7.onMouseLeave, Y4 = e7.toggleSerie, H2 = k2({ itemCount: i5.length, itemWidth: d2, itemHeight: h3, itemsSpacing: u2, direction: r5, padding: a4 }).padding, E2 = "row" === r5 ? d2 + u2 : 0, j2 = "column" === r5 ? h3 + u2 : 0;
  return (0, import_jsx_runtime2.jsx)("g", { transform: "translate(" + n6 + "," + o4 + ")", children: i5.map(function(e8, i6) {
    return (0, import_jsx_runtime2.jsx)(B2, { data: e8, x: i6 * E2 + H2.left, y: i6 * j2 + H2.top, width: d2, height: h3, direction: m3, justify: c2, effects: s3, textColor: v5, background: y3, opacity: x4, symbolShape: S4, symbolSize: A2, symbolSpacing: W3, symbolBorderWidth: z2, symbolBorderColor: C3, onClick: O4, onMouseEnter: w4, onMouseLeave: X4, toggleSerie: Y4 }, i6);
  }) });
};
var X3 = function(e7) {
  var i5 = e7.data, n6 = e7.containerWidth, o4 = e7.containerHeight, r5 = e7.translateX, l3 = void 0 === r5 ? 0 : r5, a4 = e7.translateY, c2 = void 0 === a4 ? 0 : a4, s3 = e7.anchor, d2 = e7.direction, h3 = e7.padding, g5 = void 0 === h3 ? 0 : h3, m3 = e7.justify, f4 = e7.itemsSpacing, u2 = void 0 === f4 ? 0 : f4, v5 = e7.itemWidth, p5 = e7.itemHeight, y3 = e7.itemDirection, b5 = e7.itemTextColor, S4 = e7.itemBackground, A2 = e7.itemOpacity, W3 = e7.symbolShape, z2 = e7.symbolSize, C3 = e7.symbolSpacing, O4 = e7.symbolBorderWidth, B3 = e7.symbolBorderColor, X4 = e7.onClick, Y4 = e7.onMouseEnter, H2 = e7.onMouseLeave, E2 = e7.toggleSerie, j2 = e7.effects, T4 = k2({ itemCount: i5.length, itemsSpacing: u2, itemWidth: v5, itemHeight: p5, direction: d2, padding: g5 }), L2 = T4.width, M = T4.height, F = x({ anchor: s3, translateX: l3, translateY: c2, containerWidth: n6, containerHeight: o4, width: L2, height: M }), P4 = F.x, R = F.y;
  return (0, import_jsx_runtime2.jsx)(w2, { data: i5, x: P4, y: R, direction: d2, padding: g5, justify: m3, effects: j2, itemsSpacing: u2, itemWidth: v5, itemHeight: p5, itemDirection: y3, itemTextColor: b5, itemBackground: S4, itemOpacity: A2, symbolShape: W3, symbolSize: z2, symbolSpacing: C3, symbolBorderWidth: O4, symbolBorderColor: B3, onClick: X4, onMouseEnter: Y4, onMouseLeave: H2, toggleSerie: "boolean" == typeof E2 ? void 0 : E2 });
};
var Y3 = { start: "left", middle: "center", end: "right" };
var H = function(t7, e7) {
  var i5 = e7.data, n6 = e7.containerWidth, o4 = e7.containerHeight, r5 = e7.translateX, l3 = void 0 === r5 ? 0 : r5, a4 = e7.translateY, c2 = void 0 === a4 ? 0 : a4, s3 = e7.anchor, d2 = e7.direction, h3 = e7.padding, g5 = void 0 === h3 ? 0 : h3, m3 = e7.justify, f4 = void 0 !== m3 && m3, u2 = e7.itemsSpacing, v5 = void 0 === u2 ? 0 : u2, p5 = e7.itemWidth, y3 = e7.itemHeight, b5 = e7.itemDirection, A2 = void 0 === b5 ? "left-to-right" : b5, W3 = e7.itemTextColor, z2 = e7.symbolSize, C3 = void 0 === z2 ? 16 : z2, O4 = e7.symbolSpacing, B3 = void 0 === O4 ? 8 : O4, w4 = e7.theme, X4 = k2({ itemCount: i5.length, itemWidth: p5, itemHeight: y3, itemsSpacing: v5, direction: d2, padding: g5 }), H2 = X4.width, E2 = X4.height, j2 = X4.padding, T4 = x({ anchor: s3, translateX: l3, translateY: c2, containerWidth: n6, containerHeight: o4, width: H2, height: E2 }), L2 = T4.x, M = T4.y, F = "row" === d2 ? p5 + v5 : 0, P4 = "column" === d2 ? y3 + v5 : 0;
  t7.save(), t7.translate(L2, M), t7.font = w4.legends.text.fontSize + "px " + (w4.legends.text.fontFamily || "sans-serif"), i5.forEach(function(e8, i6) {
    var n7, o5, r6 = i6 * F + j2.left, l4 = i6 * P4 + j2.top, a5 = S2({ direction: A2, justify: f4, symbolSize: C3, symbolSpacing: B3, width: p5, height: y3 }), c3 = a5.symbolX, s4 = a5.symbolY, d3 = a5.labelX, h4 = a5.labelY, g6 = a5.labelAnchor, m4 = a5.labelAlignment;
    t7.fillStyle = null != (n7 = e8.color) ? n7 : "black", t7.fillRect(r6 + c3, l4 + s4, C3, C3), t7.textAlign = Y3[g6], "central" === m4 && (t7.textBaseline = "middle"), t7.fillStyle = null != (o5 = null != W3 ? W3 : w4.legends.text.fill) ? o5 : "black", t7.fillText(String(e8.label), r6 + d3, l4 + h4);
  }), t7.restore();
};
var T2 = { data: import_prop_types3.default.arrayOf(import_prop_types3.default.object), anchor: import_prop_types3.default.oneOf(["top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", "center"]).isRequired, translateX: import_prop_types3.default.number, translateY: import_prop_types3.default.number, direction: import_prop_types3.default.oneOf(["row", "column"]).isRequired, itemsSpacing: import_prop_types3.default.number, itemWidth: import_prop_types3.default.number.isRequired, itemHeight: import_prop_types3.default.number.isRequired, itemDirection: import_prop_types3.default.oneOf(["left-to-right", "right-to-left", "top-to-bottom", "bottom-to-top"]), itemTextColor: import_prop_types3.default.string, itemBackground: import_prop_types3.default.string, itemOpacity: import_prop_types3.default.number, symbolShape: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["circle", "diamond", "square", "triangle"]), import_prop_types3.default.func]), symbolSize: import_prop_types3.default.number, symbolSpacing: import_prop_types3.default.number, symbolBorderWidth: import_prop_types3.default.number, symbolBorderColor: import_prop_types3.default.string, onClick: import_prop_types3.default.func, onMouseEnter: import_prop_types3.default.func, onMouseLeave: import_prop_types3.default.func, effects: import_prop_types3.default.arrayOf(import_prop_types3.default.shape({ on: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["hover"])]).isRequired, style: import_prop_types3.default.shape({ itemTextColor: import_prop_types3.default.string, itemBackground: import_prop_types3.default.string, itemOpacity: import_prop_types3.default.number, symbolSize: import_prop_types3.default.number, symbolBorderWidth: import_prop_types3.default.number, symbolBorderColor: import_prop_types3.default.string }).isRequired })) };

// node_modules/@nivo/line/node_modules/@nivo/tooltip/dist/nivo-tooltip.es.js
var import_react7 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function v3() {
  return v3 = Object.assign || function(t7) {
    for (var o4 = 1; o4 < arguments.length; o4++) {
      var i5 = arguments[o4];
      for (var n6 in i5)
        Object.prototype.hasOwnProperty.call(i5, n6) && (t7[n6] = i5[n6]);
    }
    return t7;
  }, v3.apply(this, arguments);
}
var x2 = { pointerEvents: "none", position: "absolute", zIndex: 10, top: 0, left: 0 };
var m2 = function(t7, o4) {
  return "translate(" + t7 + "px, " + o4 + "px)";
};
var g3 = (0, import_react7.memo)(function(t7) {
  var i5, n6 = t7.position, r5 = t7.anchor, e7 = t7.children, l3 = Vt(), d2 = tt(), p5 = d2.animate, f4 = d2.config, g5 = Ft(), b5 = g5[0], w4 = g5[1], T4 = (0, import_react7.useRef)(false), C3 = void 0, E2 = false, P4 = w4.width > 0 && w4.height > 0, N3 = Math.round(n6[0]), V3 = Math.round(n6[1]);
  P4 && ("top" === r5 ? (N3 -= w4.width / 2, V3 -= w4.height + 14) : "right" === r5 ? (N3 += 14, V3 -= w4.height / 2) : "bottom" === r5 ? (N3 -= w4.width / 2, V3 += 14) : "left" === r5 ? (N3 -= w4.width + 14, V3 -= w4.height / 2) : "center" === r5 && (N3 -= w4.width / 2, V3 -= w4.height / 2), C3 = { transform: m2(N3, V3) }, T4.current || (E2 = true), T4.current = [N3, V3]);
  var j2 = useSpring({ to: C3, config: f4, immediate: !p5 || E2 }), O4 = v3({}, x2, l3.tooltip, { transform: null != (i5 = j2.transform) ? i5 : m2(N3, V3) });
  return (0, import_jsx_runtime3.jsx)(animated.div, { ref: b5, style: O4, children: e7 });
});
g3.displayName = "TooltipWrapper";
var b3 = (0, import_react7.memo)(function(t7) {
  var o4 = t7.size, i5 = void 0 === o4 ? 12 : o4, n6 = t7.color, r5 = t7.style;
  return (0, import_jsx_runtime3.jsx)("span", { style: v3({ display: "block", width: i5, height: i5, background: n6 }, void 0 === r5 ? {} : r5) });
});
var w3 = (0, import_react7.memo)(function(t7) {
  var o4, i5 = t7.id, n6 = t7.value, r5 = t7.format, e7 = t7.enableChip, l3 = void 0 !== e7 && e7, a4 = t7.color, c2 = t7.renderContent, h3 = Vt(), u2 = Xt(r5);
  if ("function" == typeof c2)
    o4 = c2();
  else {
    var f4 = n6;
    void 0 !== u2 && void 0 !== f4 && (f4 = u2(f4)), o4 = (0, import_jsx_runtime3.jsxs)("div", { style: h3.tooltip.basic, children: [l3 && (0, import_jsx_runtime3.jsx)(b3, { color: a4, style: h3.tooltip.chip }), void 0 !== f4 ? (0, import_jsx_runtime3.jsxs)("span", { children: [i5, ": ", (0, import_jsx_runtime3.jsx)("strong", { children: "" + f4 })] }) : i5] });
  }
  return (0, import_jsx_runtime3.jsx)("div", { style: h3.tooltip.container, children: o4 });
});
var T3 = { width: "100%", borderCollapse: "collapse" };
var C2 = (0, import_react7.memo)(function(t7) {
  var o4, i5 = t7.title, n6 = t7.rows, r5 = void 0 === n6 ? [] : n6, e7 = t7.renderContent, l3 = Vt();
  return r5.length ? (o4 = "function" == typeof e7 ? e7() : (0, import_jsx_runtime3.jsxs)("div", { children: [i5 && i5, (0, import_jsx_runtime3.jsx)("table", { style: v3({}, T3, l3.tooltip.table), children: (0, import_jsx_runtime3.jsx)("tbody", { children: r5.map(function(t8, o5) {
    return (0, import_jsx_runtime3.jsx)("tr", { children: t8.map(function(t9, o6) {
      return (0, import_jsx_runtime3.jsx)("td", { style: l3.tooltip.tableCell, children: t9 }, o6);
    }) }, o5);
  }) }) })] }), (0, import_jsx_runtime3.jsx)("div", { style: l3.tooltip.container, children: o4 })) : null;
});
C2.displayName = "TableTooltip";
var E = (0, import_react7.memo)(function(t7) {
  var o4 = t7.x0, n6 = t7.x1, r5 = t7.y0, e7 = t7.y1, l3 = Vt(), u2 = tt(), d2 = u2.animate, p5 = u2.config, f4 = (0, import_react7.useMemo)(function() {
    return v3({}, l3.crosshair.line, { pointerEvents: "none" });
  }, [l3.crosshair.line]), x4 = useSpring({ x1: o4, x2: n6, y1: r5, y2: e7, config: p5, immediate: !d2 });
  return (0, import_jsx_runtime3.jsx)(animated.line, v3({}, x4, { fill: "none", style: f4 }));
});
E.displayName = "CrosshairLine";
var P2 = (0, import_react7.memo)(function(t7) {
  var o4, i5, n6 = t7.width, r5 = t7.height, e7 = t7.type, l3 = t7.x, a4 = t7.y;
  return "cross" === e7 ? (o4 = { x0: l3, x1: l3, y0: 0, y1: r5 }, i5 = { x0: 0, x1: n6, y0: a4, y1: a4 }) : "top-left" === e7 ? (o4 = { x0: l3, x1: l3, y0: 0, y1: a4 }, i5 = { x0: 0, x1: l3, y0: a4, y1: a4 }) : "top" === e7 ? o4 = { x0: l3, x1: l3, y0: 0, y1: a4 } : "top-right" === e7 ? (o4 = { x0: l3, x1: l3, y0: 0, y1: a4 }, i5 = { x0: l3, x1: n6, y0: a4, y1: a4 }) : "right" === e7 ? i5 = { x0: l3, x1: n6, y0: a4, y1: a4 } : "bottom-right" === e7 ? (o4 = { x0: l3, x1: l3, y0: a4, y1: r5 }, i5 = { x0: l3, x1: n6, y0: a4, y1: a4 }) : "bottom" === e7 ? o4 = { x0: l3, x1: l3, y0: a4, y1: r5 } : "bottom-left" === e7 ? (o4 = { x0: l3, x1: l3, y0: a4, y1: r5 }, i5 = { x0: 0, x1: l3, y0: a4, y1: a4 }) : "left" === e7 ? i5 = { x0: 0, x1: l3, y0: a4, y1: a4 } : "x" === e7 ? o4 = { x0: l3, x1: l3, y0: 0, y1: r5 } : "y" === e7 && (i5 = { x0: 0, x1: n6, y0: a4, y1: a4 }), (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [o4 && (0, import_jsx_runtime3.jsx)(E, { x0: o4.x0, x1: o4.x1, y0: o4.y0, y1: o4.y1 }), i5 && (0, import_jsx_runtime3.jsx)(E, { x0: i5.x0, x1: i5.x1, y0: i5.y0, y1: i5.y1 })] });
});
P2.displayName = "Crosshair";
var N = (0, import_react7.createContext)({ showTooltipAt: function() {
}, showTooltipFromEvent: function() {
}, hideTooltip: function() {
} });
var V2 = { isVisible: false, position: [null, null], content: null, anchor: null };
var j = (0, import_react7.createContext)(V2);
var k3 = function() {
  var t7 = (0, import_react7.useContext)(N);
  if (void 0 === t7)
    throw new Error("useTooltip must be used within a TooltipProvider");
  return t7;
};

// node_modules/@nivo/line/dist/nivo-line.es.js
var import_prop_types4 = __toESM(require_prop_types());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());

// node_modules/@nivo/voronoi/dist/nivo-voronoi.es.js
var import_react8 = __toESM(require_react());

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n6 = points.length;
    const coords = new Float64Array(n6 * 2);
    for (let i5 = 0; i5 < n6; i5++) {
      const p5 = points[i5];
      coords[2 * i5] = getX(p5);
      coords[2 * i5 + 1] = getY(p5);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n6 = coords.length >> 1;
    if (n6 > 0 && typeof coords[0] !== "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n6 - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n6));
    this._hullPrev = new Uint32Array(n6);
    this._hullNext = new Uint32Array(n6);
    this._hullTri = new Uint32Array(n6);
    this._hullHash = new Int32Array(this._hashSize).fill(-1);
    this._ids = new Uint32Array(n6);
    this._dists = new Float64Array(n6);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n6 = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i5 = 0; i5 < n6; i5++) {
      const x4 = coords[2 * i5];
      const y3 = coords[2 * i5 + 1];
      if (x4 < minX)
        minX = x4;
      if (y3 < minY)
        minY = y3;
      if (x4 > maxX)
        maxX = x4;
      if (y3 > maxY)
        maxY = y3;
      this._ids[i5] = i5;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let minDist = Infinity;
    let i0, i1, i22;
    for (let i5 = 0; i5 < n6; i5++) {
      const d2 = dist(cx, cy, coords[2 * i5], coords[2 * i5 + 1]);
      if (d2 < minDist) {
        i0 = i5;
        minDist = d2;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity;
    for (let i5 = 0; i5 < n6; i5++) {
      if (i5 === i0)
        continue;
      const d2 = dist(i0x, i0y, coords[2 * i5], coords[2 * i5 + 1]);
      if (d2 < minDist && d2 > 0) {
        i1 = i5;
        minDist = d2;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i5 = 0; i5 < n6; i5++) {
      if (i5 === i0 || i5 === i1)
        continue;
      const r5 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i5], coords[2 * i5 + 1]);
      if (r5 < minRadius) {
        i22 = i5;
        minRadius = r5;
      }
    }
    let i2x = coords[2 * i22];
    let i2y = coords[2 * i22 + 1];
    if (minRadius === Infinity) {
      for (let i5 = 0; i5 < n6; i5++) {
        this._dists[i5] = coords[2 * i5] - coords[0] || coords[2 * i5 + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n6 - 1);
      const hull = new Uint32Array(n6);
      let j2 = 0;
      for (let i5 = 0, d0 = -Infinity; i5 < n6; i5++) {
        const id = this._ids[i5];
        if (this._dists[id] > d0) {
          hull[j2++] = id;
          d0 = this._dists[id];
        }
      }
      this.hull = hull.subarray(0, j2);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
      const i5 = i1;
      const x4 = i1x;
      const y3 = i1y;
      i1 = i22;
      i1x = i2x;
      i1y = i2y;
      i22 = i5;
      i2x = x4;
      i2y = y3;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i5 = 0; i5 < n6; i5++) {
      this._dists[i5] = dist(coords[2 * i5], coords[2 * i5 + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n6 - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i22] = i1;
    hullNext[i1] = hullPrev[i0] = i22;
    hullNext[i22] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i22] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i22;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i22, -1, -1, -1);
    for (let k5 = 0, xp, yp; k5 < this._ids.length; k5++) {
      const i5 = this._ids[k5];
      const x4 = coords[2 * i5];
      const y3 = coords[2 * i5 + 1];
      if (k5 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y3 - yp) <= EPSILON)
        continue;
      xp = x4;
      yp = y3;
      if (i5 === i0 || i5 === i1 || i5 === i22)
        continue;
      let start2 = 0;
      for (let j2 = 0, key = this._hashKey(x4, y3); j2 < this._hashSize; j2++) {
        start2 = hullHash[(key + j2) % this._hashSize];
        if (start2 !== -1 && start2 !== hullNext[start2])
          break;
      }
      start2 = hullPrev[start2];
      let e7 = start2, q;
      while (q = hullNext[e7], !orient(x4, y3, coords[2 * e7], coords[2 * e7 + 1], coords[2 * q], coords[2 * q + 1])) {
        e7 = q;
        if (e7 === start2) {
          e7 = -1;
          break;
        }
      }
      if (e7 === -1)
        continue;
      let t7 = this._addTriangle(e7, i5, hullNext[e7], -1, -1, hullTri[e7]);
      hullTri[i5] = this._legalize(t7 + 2);
      hullTri[e7] = t7;
      hullSize++;
      let n7 = hullNext[e7];
      while (q = hullNext[n7], orient(x4, y3, coords[2 * n7], coords[2 * n7 + 1], coords[2 * q], coords[2 * q + 1])) {
        t7 = this._addTriangle(n7, i5, q, hullTri[i5], -1, hullTri[n7]);
        hullTri[i5] = this._legalize(t7 + 2);
        hullNext[n7] = n7;
        hullSize--;
        n7 = q;
      }
      if (e7 === start2) {
        while (q = hullPrev[e7], orient(x4, y3, coords[2 * q], coords[2 * q + 1], coords[2 * e7], coords[2 * e7 + 1])) {
          t7 = this._addTriangle(q, i5, e7, -1, hullTri[e7], hullTri[q]);
          this._legalize(t7 + 2);
          hullTri[q] = t7;
          hullNext[e7] = e7;
          hullSize--;
          e7 = q;
        }
      }
      this._hullStart = hullPrev[i5] = e7;
      hullNext[e7] = hullPrev[n7] = i5;
      hullNext[i5] = n7;
      hullHash[this._hashKey(x4, y3)] = i5;
      hullHash[this._hashKey(coords[2 * e7], coords[2 * e7 + 1])] = e7;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i5 = 0, e7 = this._hullStart; i5 < hullSize; i5++) {
      this.hull[i5] = e7;
      e7 = hullNext[e7];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x4, y3) {
    return Math.floor(pseudoAngle(x4 - this._cx, y3 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a4) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i5 = 0;
    let ar = 0;
    while (true) {
      const b5 = halfedges[a4];
      const a0 = a4 - a4 % 3;
      ar = a0 + (a4 + 2) % 3;
      if (b5 === -1) {
        if (i5 === 0)
          break;
        a4 = EDGE_STACK[--i5];
        continue;
      }
      const b0 = b5 - b5 % 3;
      const al = a0 + (a4 + 1) % 3;
      const bl = b0 + (b5 + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a4];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a4] = p1;
        triangles[b5] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e7 = this._hullStart;
          do {
            if (this._hullTri[e7] === bl) {
              this._hullTri[e7] = a4;
              break;
            }
            e7 = this._hullPrev[e7];
          } while (e7 !== this._hullStart);
        }
        this._link(a4, hbl);
        this._link(b5, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b5 + 1) % 3;
        if (i5 < EDGE_STACK.length) {
          EDGE_STACK[i5++] = br;
        }
      } else {
        if (i5 === 0)
          break;
        a4 = EDGE_STACK[--i5];
      }
    }
    return ar;
  }
  _link(a4, b5) {
    this._halfedges[a4] = b5;
    if (b5 !== -1)
      this._halfedges[b5] = a4;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i22, a4, b5, c2) {
    const t7 = this.trianglesLen;
    this._triangles[t7] = i0;
    this._triangles[t7 + 1] = i1;
    this._triangles[t7 + 2] = i22;
    this._link(t7, a4);
    this._link(t7 + 1, b5);
    this._link(t7 + 2, c2);
    this.trianglesLen += 3;
    return t7;
  }
};
function pseudoAngle(dx, dy) {
  const p5 = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p5 : 1 + p5) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function orientIfSure(px, py, rx, ry, qx, qy) {
  const l3 = (ry - py) * (qx - px);
  const r5 = (rx - px) * (qy - py);
  return Math.abs(l3 - r5) >= 33306690738754716e-32 * Math.abs(l3 + r5) ? l3 - r5 : 0;
}
function orient(rx, ry, qx, qy, px, py) {
  const sign = orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry);
  return sign < 0;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d2 = 0.5 / (dx * ey - dy * ex);
  const x4 = (ey * bl - dy * cl) * d2;
  const y3 = (dx * cl - ex * bl) * d2;
  return x4 * x4 + y3 * y3;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d2 = 0.5 / (dx * ey - dy * ex);
  const x4 = ax + (ey * bl - dy * cl) * d2;
  const y3 = ay + (dx * cl - ex * bl) * d2;
  return { x: x4, y: y3 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i5 = left + 1; i5 <= right; i5++) {
      const temp = ids[i5];
      const tempDist = dists[temp];
      let j2 = i5 - 1;
      while (j2 >= left && dists[ids[j2]] > tempDist)
        ids[j2 + 1] = ids[j2--];
      ids[j2 + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i5 = left + 1;
    let j2 = right;
    swap(ids, median, i5);
    if (dists[ids[left]] > dists[ids[right]])
      swap(ids, left, right);
    if (dists[ids[i5]] > dists[ids[right]])
      swap(ids, i5, right);
    if (dists[ids[left]] > dists[ids[i5]])
      swap(ids, left, i5);
    const temp = ids[i5];
    const tempDist = dists[temp];
    while (true) {
      do
        i5++;
      while (dists[ids[i5]] < tempDist);
      do
        j2--;
      while (dists[ids[j2]] > tempDist);
      if (j2 < i5)
        break;
      swap(ids, i5, j2);
    }
    ids[left + 1] = ids[j2];
    ids[j2] = temp;
    if (right - i5 + 1 >= j2 - left) {
      quicksort(ids, dists, i5, right);
      quicksort(ids, dists, left, j2 - 1);
    } else {
      quicksort(ids, dists, left, j2 - 1);
      quicksort(ids, dists, i5, right);
    }
  }
}
function swap(arr, i5, j2) {
  const tmp = arr[i5];
  arr[i5] = arr[j2];
  arr[j2] = tmp;
}
function defaultGetX(p5) {
  return p5[0];
}
function defaultGetY(p5) {
  return p5[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon = 1e-6;
var Path = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x4, y3) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x4, y3) {
    this._ += `L${this._x1 = +x4},${this._y1 = +y3}`;
  }
  arc(x4, y3, r5) {
    x4 = +x4, y3 = +y3, r5 = +r5;
    const x0 = x4 + r5;
    const y0 = y3;
    if (r5 < 0)
      throw new Error("negative radius");
    if (this._x1 === null)
      this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon)
      this._ += "L" + x0 + "," + y0;
    if (!r5)
      return;
    this._ += `A${r5},${r5},0,1,1,${x4 - r5},${y3}A${r5},${r5},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x4, y3, w4, h3) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y3}h${+w4}v${+h3}h${-w4}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x4, y3) {
    this._.push([x4, y3]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x4, y3) {
    this._.push([x4, y3]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
      throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i5 = 0, j2 = 0, n6 = triangles.length, x4, y3; i5 < n6; i5 += 3, j2 += 2) {
      const t1 = triangles[i5] * 2;
      const t22 = triangles[i5 + 1] * 2;
      const t32 = triangles[i5 + 2] * 2;
      const x12 = points[t1];
      const y12 = points[t1 + 1];
      const x22 = points[t22];
      const y22 = points[t22 + 1];
      const x32 = points[t32];
      const y32 = points[t32 + 1];
      const dx = x22 - x12;
      const dy = y22 - y12;
      const ex = x32 - x12;
      const ey = y32 - y12;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;
      if (!ab) {
        x4 = (x12 + x32) / 2 - 1e8 * ey;
        y3 = (y12 + y32) / 2 + 1e8 * ex;
      } else if (Math.abs(ab) < 1e-8) {
        x4 = (x12 + x32) / 2;
        y3 = (y12 + y32) / 2;
      } else {
        const d2 = 1 / ab;
        x4 = x12 + (ey * bl - dy * cl) * d2;
        y3 = y12 + (dx * cl - ex * bl) * d2;
      }
      circumcenters[j2] = x4;
      circumcenters[j2 + 1] = y3;
    }
    let h3 = hull[hull.length - 1];
    let p0, p1 = h3 * 4;
    let x0, x1 = points[2 * h3];
    let y0, y1 = points[2 * h3 + 1];
    vectors.fill(0);
    for (let i5 = 0; i5 < hull.length; ++i5) {
      h3 = hull[i5];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h3 * 4, x1 = points[2 * h3], y1 = points[2 * h3 + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1)
      return null;
    for (let i5 = 0, n6 = halfedges.length; i5 < n6; ++i5) {
      const j2 = halfedges[i5];
      if (j2 < i5)
        continue;
      const ti2 = Math.floor(i5 / 3) * 2;
      const tj = Math.floor(j2 / 3) * 2;
      const xi = circumcenters[ti2];
      const yi2 = circumcenters[ti2 + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi2, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i5 = 0; i5 < hull.length; ++i5) {
      h0 = h1, h1 = hull[i5];
      const t7 = Math.floor(inedges[h1] / 3) * 2;
      const x4 = circumcenters[t7];
      const y3 = circumcenters[t7 + 1];
      const v5 = h0 * 4;
      const p5 = this._project(x4, y3, vectors[v5 + 2], vectors[v5 + 3]);
      if (p5)
        this._renderSegment(x4, y3, p5[0], p5[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i5, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const points = this._clip(i5);
    if (points === null || !points.length)
      return;
    context.moveTo(points[0], points[1]);
    let n6 = points.length;
    while (points[0] === points[n6 - 2] && points[1] === points[n6 - 1] && n6 > 1)
      n6 -= 2;
    for (let i6 = 2; i6 < n6; i6 += 2) {
      if (points[i6] !== points[i6 - 2] || points[i6 + 1] !== points[i6 - 1])
        context.lineTo(points[i6], points[i6 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i5 = 0, n6 = points.length / 2; i5 < n6; ++i5) {
      const cell = this.cellPolygon(i5);
      if (cell)
        cell.index = i5, yield cell;
    }
  }
  cellPolygon(i5) {
    const polygon = new Polygon();
    this.renderCell(i5, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S4;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S4 = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S4[0], S4[1]);
      context.lineTo(S4[2], S4[3]);
    }
  }
  contains(i5, x4, y3) {
    if ((x4 = +x4, x4 !== x4) || (y3 = +y3, y3 !== y3))
      return false;
    return this.delaunay._step(i5, x4, y3) === i5;
  }
  *neighbors(i5) {
    const ci = this._clip(i5);
    if (ci)
      for (const j2 of this.delaunay.neighbors(i5)) {
        const cj = this._clip(j2);
        if (cj)
          loop:
            for (let ai = 0, li = ci.length; ai < li; ai += 2) {
              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                  yield j2;
                  break loop;
                }
              }
            }
      }
  }
  _cell(i5) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i5];
    if (e0 === -1)
      return null;
    const points = [];
    let e7 = e0;
    do {
      const t7 = Math.floor(e7 / 3);
      points.push(circumcenters[t7 * 2], circumcenters[t7 * 2 + 1]);
      e7 = e7 % 3 === 2 ? e7 - 2 : e7 + 1;
      if (triangles[e7] !== i5)
        break;
      e7 = halfedges[e7];
    } while (e7 !== e0 && e7 !== -1);
    return points;
  }
  _clip(i5) {
    if (i5 === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i5);
    if (points === null)
      return null;
    const { vectors: V3 } = this;
    const v5 = i5 * 4;
    return V3[v5] || V3[v5 + 1] ? this._clipInfinite(i5, points, V3[v5], V3[v5 + 1], V3[v5 + 2], V3[v5 + 3]) : this._clipFinite(i5, points);
  }
  _clipFinite(i5, points) {
    const n6 = points.length;
    let P4 = null;
    let x0, y0, x1 = points[n6 - 2], y1 = points[n6 - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j2 = 0; j2 < n6; j2 += 2) {
      x0 = x1, y0 = y1, x1 = points[j2], y1 = points[j2 + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P4)
          P4.push(x1, y1);
        else
          P4 = [x1, y1];
      } else {
        let S4, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S4 = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null)
            continue;
          [sx0, sy0, sx1, sy1] = S4;
        } else {
          if ((S4 = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null)
            continue;
          [sx1, sy1, sx0, sy0] = S4;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1)
            this._edge(i5, e0, e1, P4, P4.length);
          if (P4)
            P4.push(sx0, sy0);
          else
            P4 = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1)
          this._edge(i5, e0, e1, P4, P4.length);
        if (P4)
          P4.push(sx1, sy1);
        else
          P4 = [sx1, sy1];
      }
    }
    if (P4) {
      e0 = e1, e1 = this._edgecode(P4[0], P4[1]);
      if (e0 && e1)
        this._edge(i5, e0, e1, P4, P4.length);
    } else if (this.contains(i5, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P4;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0)
        return [x0, y0, x1, y1];
      if (c0 & c1)
        return null;
      let x4, y3, c2 = c0 || c1;
      if (c2 & 8)
        x4 = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y3 = this.ymax;
      else if (c2 & 4)
        x4 = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y3 = this.ymin;
      else if (c2 & 2)
        y3 = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x4 = this.xmax;
      else
        y3 = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x4 = this.xmin;
      if (c0)
        x0 = x4, y0 = y3, c0 = this._regioncode(x0, y0);
      else
        x1 = x4, y1 = y3, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i5, points, vx0, vy0, vxn, vyn) {
    let P4 = Array.from(points), p5;
    if (p5 = this._project(P4[0], P4[1], vx0, vy0))
      P4.unshift(p5[0], p5[1]);
    if (p5 = this._project(P4[P4.length - 2], P4[P4.length - 1], vxn, vyn))
      P4.push(p5[0], p5[1]);
    if (P4 = this._clipFinite(i5, P4)) {
      for (let j2 = 0, n6 = P4.length, c0, c1 = this._edgecode(P4[n6 - 2], P4[n6 - 1]); j2 < n6; j2 += 2) {
        c0 = c1, c1 = this._edgecode(P4[j2], P4[j2 + 1]);
        if (c0 && c1)
          j2 = this._edge(i5, c0, c1, P4, j2), n6 = P4.length;
      }
    } else if (this.contains(i5, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P4 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P4;
  }
  _edge(i5, e0, e1, P4, j2) {
    while (e0 !== e1) {
      let x4, y3;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x4 = this.xmax, y3 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x4 = this.xmax, y3 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x4 = this.xmin, y3 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x4 = this.xmin, y3 = this.ymin;
          break;
      }
      if ((P4[j2] !== x4 || P4[j2 + 1] !== y3) && this.contains(i5, x4, y3)) {
        P4.splice(j2, 0, x4, y3), j2 += 2;
      }
    }
    if (P4.length > 4) {
      for (let i6 = 0; i6 < P4.length; i6 += 2) {
        const j3 = (i6 + 2) % P4.length, k5 = (i6 + 4) % P4.length;
        if (P4[i6] === P4[j3] && P4[j3] === P4[k5] || P4[i6 + 1] === P4[j3 + 1] && P4[j3 + 1] === P4[k5 + 1])
          P4.splice(j3, 2), i6 -= 2;
      }
    }
    return j2;
  }
  _project(x0, y0, vx, vy) {
    let t7 = Infinity, c2, x4, y3;
    if (vy < 0) {
      if (y0 <= this.ymin)
        return null;
      if ((c2 = (this.ymin - y0) / vy) < t7)
        y3 = this.ymin, x4 = x0 + (t7 = c2) * vx;
    } else if (vy > 0) {
      if (y0 >= this.ymax)
        return null;
      if ((c2 = (this.ymax - y0) / vy) < t7)
        y3 = this.ymax, x4 = x0 + (t7 = c2) * vx;
    }
    if (vx > 0) {
      if (x0 >= this.xmax)
        return null;
      if ((c2 = (this.xmax - x0) / vx) < t7)
        x4 = this.xmax, y3 = y0 + (t7 = c2) * vy;
    } else if (vx < 0) {
      if (x0 <= this.xmin)
        return null;
      if ((c2 = (this.xmin - x0) / vx) < t7)
        x4 = this.xmin, y3 = y0 + (t7 = c2) * vy;
    }
    return [x4, y3];
  }
  _edgecode(x4, y3) {
    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y3 === this.ymin ? 4 : y3 === this.ymax ? 8 : 0);
  }
  _regioncode(x4, y3) {
    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y3 < this.ymin ? 4 : y3 > this.ymax ? 8 : 0);
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau = 2 * Math.PI;
var pow = Math.pow;
function pointX(p5) {
  return p5[0];
}
function pointY(p5) {
  return p5[1];
}
function collinear(d2) {
  const { triangles, coords } = d2;
  for (let i5 = 0; i5 < triangles.length; i5 += 3) {
    const a4 = 2 * triangles[i5], b5 = 2 * triangles[i5 + 1], c2 = 2 * triangles[i5 + 2], cross = (coords[c2] - coords[a4]) * (coords[b5 + 1] - coords[a4 + 1]) - (coords[b5] - coords[a4]) * (coords[c2 + 1] - coords[a4 + 1]);
    if (cross > 1e-10)
      return false;
  }
  return true;
}
function jitter(x4, y3, r5) {
  return [x4 + Math.sin(x4 + y3) * r5, y3 + Math.cos(x4 - y3) * r5];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d2 = this._delaunator, points = this.points;
    if (d2.hull && d2.hull.length > 2 && collinear(d2)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_2, i5) => i5).sort((i5, j2) => points[2 * i5] - points[2 * j2] || points[2 * i5 + 1] - points[2 * j2 + 1]);
      const e7 = this.collinear[0], f4 = this.collinear[this.collinear.length - 1], bounds = [points[2 * e7], points[2 * e7 + 1], points[2 * f4], points[2 * f4 + 1]], r5 = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i5 = 0, n6 = points.length / 2; i5 < n6; ++i5) {
        const p5 = jitter(points[2 * i5], points[2 * i5 + 1], r5);
        points[2 * i5] = p5[0];
        points[2 * i5 + 1] = p5[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e7 = 0, n6 = halfedges.length; e7 < n6; ++e7) {
      const p5 = triangles[e7 % 3 === 2 ? e7 - 2 : e7 + 1];
      if (halfedges[e7] === -1 || inedges[p5] === -1)
        inedges[p5] = e7;
    }
    for (let i5 = 0, n6 = hull.length; i5 < n6; ++i5) {
      hullIndex[hull[i5]] = i5;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2)
        inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i5) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l3 = collinear2.indexOf(i5);
      if (l3 > 0)
        yield collinear2[l3 - 1];
      if (l3 < collinear2.length - 1)
        yield collinear2[l3 + 1];
      return;
    }
    const e0 = inedges[i5];
    if (e0 === -1)
      return;
    let e7 = e0, p0 = -1;
    do {
      yield p0 = triangles[e7];
      e7 = e7 % 3 === 2 ? e7 - 2 : e7 + 1;
      if (triangles[e7] !== i5)
        return;
      e7 = halfedges[e7];
      if (e7 === -1) {
        const p5 = hull[(_hullIndex[i5] + 1) % hull.length];
        if (p5 !== p0)
          yield p5;
        return;
      }
    } while (e7 !== e0);
  }
  find(x4, y3, i5 = 0) {
    if ((x4 = +x4, x4 !== x4) || (y3 = +y3, y3 !== y3))
      return -1;
    const i0 = i5;
    let c2;
    while ((c2 = this._step(i5, x4, y3)) >= 0 && c2 !== i5 && c2 !== i0)
      i5 = c2;
    return c2;
  }
  _step(i5, x4, y3) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i5] === -1 || !points.length)
      return (i5 + 1) % (points.length >> 1);
    let c2 = i5;
    let dc = pow(x4 - points[i5 * 2], 2) + pow(y3 - points[i5 * 2 + 1], 2);
    const e0 = inedges[i5];
    let e7 = e0;
    do {
      let t7 = triangles[e7];
      const dt = pow(x4 - points[t7 * 2], 2) + pow(y3 - points[t7 * 2 + 1], 2);
      if (dt < dc)
        dc = dt, c2 = t7;
      e7 = e7 % 3 === 2 ? e7 - 2 : e7 + 1;
      if (triangles[e7] !== i5)
        break;
      e7 = halfedges[e7];
      if (e7 === -1) {
        e7 = hull[(_hullIndex[i5] + 1) % hull.length];
        if (e7 !== t7) {
          if (pow(x4 - points[e7 * 2], 2) + pow(y3 - points[e7 * 2 + 1], 2) < dc)
            return e7;
        }
        break;
      }
    } while (e7 !== e0);
    return c2;
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i5 = 0, n6 = halfedges.length; i5 < n6; ++i5) {
      const j2 = halfedges[i5];
      if (j2 < i5)
        continue;
      const ti2 = triangles[i5] * 2;
      const tj = triangles[j2] * 2;
      context.moveTo(points[ti2], points[ti2 + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r5 = 2) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points } = this;
    for (let i5 = 0, n6 = points.length; i5 < n6; i5 += 2) {
      const x4 = points[i5], y3 = points[i5 + 1];
      context.moveTo(x4 + r5, y3);
      context.arc(x4, y3, r5, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { hull, points } = this;
    const h3 = hull[0] * 2, n6 = hull.length;
    context.moveTo(points[h3], points[h3 + 1]);
    for (let i5 = 1; i5 < n6; ++i5) {
      const h4 = 2 * hull[i5];
      context.lineTo(points[h4], points[h4 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i5, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, triangles } = this;
    const t0 = triangles[i5 *= 3] * 2;
    const t1 = triangles[i5 + 1] * 2;
    const t22 = triangles[i5 + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t22], points[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i5 = 0, n6 = triangles.length / 3; i5 < n6; ++i5) {
      yield this.trianglePolygon(i5);
    }
  }
  trianglePolygon(i5) {
    const polygon = new Polygon();
    this.renderTriangle(i5, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n6 = points.length;
  const array = new Float64Array(n6 * 2);
  for (let i5 = 0; i5 < n6; ++i5) {
    const p5 = points[i5];
    array[i5 * 2] = fx.call(that, p5, i5, points);
    array[i5 * 2 + 1] = fy.call(that, p5, i5, points);
  }
  return array;
}
function* flatIterable(points, fx, fy, that) {
  let i5 = 0;
  for (const p5 of points) {
    yield fx.call(that, p5, i5, points);
    yield fy.call(that, p5, i5, points);
    ++i5;
  }
}

// node_modules/@nivo/voronoi/dist/nivo-voronoi.es.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var g4 = function(n6) {
  return "function" == typeof n6 ? n6 : function(e7) {
    return e7[n6];
  };
};
var b4 = function(n6) {
  var e7 = n6.points, i5 = n6.x, o4 = void 0 === i5 ? "x" : i5, t7 = n6.y, r5 = void 0 === t7 ? "y" : t7, l3 = g4(o4), u2 = g4(r5);
  return e7.map(function(n7) {
    return [l3(n7), u2(n7)];
  });
};
var k4 = function(n6) {
  var e7 = n6.points, i5 = n6.width, o4 = n6.height, t7 = n6.debug, r5 = Delaunay.from(e7), l3 = t7 ? r5.voronoi([0, 0, i5, o4]) : void 0;
  return { delaunay: r5, voronoi: l3 };
};
var x3 = function(e7) {
  var i5 = e7.points, o4 = e7.x, t7 = e7.y, r5 = e7.width, l3 = e7.height, u2 = e7.debug, a4 = (0, import_react8.useMemo)(function() {
    return b4({ points: i5, x: o4, y: t7 });
  }, [i5, o4, t7]);
  return (0, import_react8.useMemo)(function() {
    return k4({ points: a4, width: r5, height: l3, debug: u2 });
  }, [a4, r5, l3, u2]);
};
var P3 = function(e7) {
  var i5 = e7.nodes, l3 = e7.width, u2 = e7.height, a4 = e7.x, d2 = e7.y, c2 = e7.onMouseEnter, h3 = e7.onMouseMove, m3 = e7.onMouseLeave, y3 = e7.onClick, g5 = e7.debug, b5 = (0, import_react8.useRef)(null), k5 = (0, import_react8.useState)(null), C3 = k5[0], L2 = k5[1], w4 = x3({ points: i5, x: a4, y: d2, width: l3, height: u2, debug: g5 }), W3 = w4.delaunay, D = w4.voronoi, M = (0, import_react8.useMemo)(function() {
    if (g5 && D)
      return D.render();
  }, [g5, D]), P4 = (0, import_react8.useCallback)(function(n6) {
    if (!b5.current)
      return [null, null];
    var e8 = Qi(b5.current, n6), o4 = e8[0], t7 = e8[1], r5 = W3.find(o4, t7);
    return [r5, void 0 !== r5 ? i5[r5] : null];
  }, [b5, W3]), O4 = (0, import_react8.useCallback)(function(n6) {
    var e8 = P4(n6), i6 = e8[0], o4 = e8[1];
    L2(i6), o4 && (null == c2 || c2(o4, n6));
  }, [P4, L2, c2]), S4 = (0, import_react8.useCallback)(function(n6) {
    var e8 = P4(n6), i6 = e8[0], o4 = e8[1];
    L2(i6), o4 && (null == h3 || h3(o4, n6));
  }, [P4, L2, h3]), j2 = (0, import_react8.useCallback)(function(n6) {
    if (L2(null), m3) {
      var e8 = void 0;
      null !== C3 && (e8 = i5[C3]), e8 && m3(e8, n6);
    }
  }, [L2, C3, m3, i5]), z2 = (0, import_react8.useCallback)(function(n6) {
    var e8 = P4(n6), i6 = e8[0], o4 = e8[1];
    L2(i6), o4 && (null == y3 || y3(o4, n6));
  }, [P4, L2, y3]);
  return (0, import_jsx_runtime4.jsxs)("g", { ref: b5, children: [g5 && D && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [(0, import_jsx_runtime4.jsx)("path", { d: M, stroke: "red", strokeWidth: 1, opacity: 0.75 }), null !== C3 && (0, import_jsx_runtime4.jsx)("path", { fill: "pink", opacity: 0.35, d: D.renderCell(C3) })] }), (0, import_jsx_runtime4.jsx)("rect", { width: l3, height: u2, fill: "red", opacity: 0, style: { cursor: "auto" }, onMouseEnter: O4, onMouseMove: S4, onMouseLeave: j2, onClick: z2 })] });
};
var O3 = function(n6, e7) {
  n6.save(), n6.globalAlpha = 0.75, n6.beginPath(), e7.render(n6), n6.strokeStyle = "red", n6.lineWidth = 1, n6.stroke(), n6.restore();
};
var S3 = function(n6, e7, i5) {
  n6.save(), n6.globalAlpha = 0.35, n6.beginPath(), e7.renderCell(i5, n6), n6.fillStyle = "red", n6.fill(), n6.restore();
};

// node_modules/@nivo/line/dist/nivo-line.es.js
function ie() {
  return ie = Object.assign || function(e7) {
    for (var r5 = 1; r5 < arguments.length; r5++) {
      var i5 = arguments[r5];
      for (var n6 in i5)
        Object.prototype.hasOwnProperty.call(i5, n6) && (e7[n6] = i5[n6]);
    }
    return e7;
  }, ie.apply(this, arguments);
}
var ne = function(e7) {
  var r5 = e7.point;
  return (0, import_jsx_runtime5.jsx)(w3, { id: (0, import_jsx_runtime5.jsxs)("span", { children: ["x: ", (0, import_jsx_runtime5.jsx)("strong", { children: r5.data.xFormatted }), ", y:", " ", (0, import_jsx_runtime5.jsx)("strong", { children: r5.data.yFormatted })] }), enableChip: true, color: r5.serieColor });
};
ne.propTypes = { point: import_prop_types4.default.object.isRequired };
var te = (0, import_react9.memo)(ne);
var oe = function(e7) {
  var r5 = e7.slice, i5 = e7.axis, n6 = Vt(), t7 = "x" === i5 ? "y" : "x";
  return (0, import_jsx_runtime5.jsx)(C2, { rows: r5.points.map(function(e8) {
    return [(0, import_jsx_runtime5.jsx)(b3, { color: e8.serieColor, style: n6.tooltip.chip }, "chip"), e8.serieId, (0, import_jsx_runtime5.jsx)("span", { style: n6.tooltip.tableCellValue, children: e8.data[t7 + "Formatted"] }, "value")];
  }) });
};
oe.propTypes = { slice: import_prop_types4.default.object.isRequired, axis: import_prop_types4.default.oneOf(["x", "y"]).isRequired };
var ae = (0, import_react9.memo)(oe);
var se = { data: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ id: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]).isRequired, data: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ x: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]), y: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]) })).isRequired })).isRequired, xScale: import_prop_types4.default.object.isRequired, xFormat: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.string]), yScale: import_prop_types4.default.object.isRequired, yFormat: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.string]), layers: import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["grid", "markers", "axes", "areas", "crosshair", "lines", "slices", "points", "mesh", "legends"]), import_prop_types4.default.func])).isRequired, curve: Rt.isRequired, axisTop: A, axisRight: A, axisBottom: A, axisLeft: A, enableGridX: import_prop_types4.default.bool.isRequired, enableGridY: import_prop_types4.default.bool.isRequired, gridXValues: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]))]), gridYValues: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]))]), enablePoints: import_prop_types4.default.bool.isRequired, pointSymbol: import_prop_types4.default.func, pointSize: import_prop_types4.default.number.isRequired, pointColor: import_prop_types4.default.any.isRequired, pointBorderWidth: import_prop_types4.default.number.isRequired, pointBorderColor: import_prop_types4.default.any.isRequired, enablePointLabel: import_prop_types4.default.bool.isRequired, pointLabel: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.func]).isRequired, markers: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ axis: import_prop_types4.default.oneOf(["x", "y"]).isRequired, value: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]).isRequired, style: import_prop_types4.default.object })), colors: Xe.isRequired, enableArea: import_prop_types4.default.bool.isRequired, areaOpacity: import_prop_types4.default.number.isRequired, areaBlendMode: Mt.isRequired, areaBaselineValue: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]).isRequired, lineWidth: import_prop_types4.default.number.isRequired, legends: import_prop_types4.default.arrayOf(import_prop_types4.default.shape(T2)).isRequired, isInteractive: import_prop_types4.default.bool.isRequired, debugMesh: import_prop_types4.default.bool.isRequired, tooltip: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]).isRequired, enableSlices: import_prop_types4.default.oneOf(["x", "y", false]).isRequired, debugSlices: import_prop_types4.default.bool.isRequired, sliceTooltip: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]).isRequired, enableCrosshair: import_prop_types4.default.bool.isRequired, crosshairType: import_prop_types4.default.string.isRequired };
var le = ie({}, se, { enablePointLabel: import_prop_types4.default.bool.isRequired, role: import_prop_types4.default.string.isRequired, useMesh: import_prop_types4.default.bool.isRequired }, et, kt);
var ue = ie({ pixelRatio: import_prop_types4.default.number.isRequired }, se);
var de = { curve: "linear", xScale: { type: "point" }, yScale: { type: "linear", min: 0, max: "auto" }, layers: ["grid", "markers", "axes", "areas", "crosshair", "lines", "points", "slices", "mesh", "legends"], axisBottom: {}, axisLeft: {}, enableGridX: true, enableGridY: true, enablePoints: true, pointSize: 6, pointColor: { from: "color" }, pointBorderWidth: 0, pointBorderColor: { theme: "background" }, enablePointLabel: false, pointLabel: "yFormatted", colors: { scheme: "nivo" }, enableArea: false, areaBaselineValue: 0, areaOpacity: 0.2, areaBlendMode: "normal", lineWidth: 2, legends: [], isInteractive: true, tooltip: te, enableSlices: false, debugSlices: false, sliceTooltip: ae, debugMesh: false, enableCrosshair: true, crosshairType: "bottom-left" };
var ce = ie({}, de, { enablePointLabel: false, useMesh: false, animate: true, motionConfig: "gentle", defs: [], fill: [], role: "img" });
var fe = ie({}, de, { pixelRatio: "undefined" != typeof window && window.devicePixelRatio || 1 });
var pe = function(e7) {
  var i5 = e7.curve;
  return (0, import_react9.useMemo)(function() {
    return line_default().defined(function(e8) {
      return null !== e8.x && null !== e8.y;
    }).x(function(e8) {
      return e8.x;
    }).y(function(e8) {
      return e8.y;
    }).curve(qt(i5));
  }, [i5]);
};
var he = function(e7) {
  var i5 = e7.curve, n6 = e7.yScale, t7 = e7.areaBaselineValue;
  return (0, import_react9.useMemo)(function() {
    return area_default().defined(function(e8) {
      return null !== e8.x && null !== e8.y;
    }).x(function(e8) {
      return e8.x;
    }).y1(function(e8) {
      return e8.y;
    }).curve(qt(i5)).y0(n6(t7));
  }, [i5, n6, t7]);
};
var ye = function(e7) {
  var i5 = e7.enableSlices, n6 = e7.points, t7 = e7.width, o4 = e7.height;
  return (0, import_react9.useMemo)(function() {
    if (false === i5)
      return [];
    if ("x" === i5) {
      var e8 = /* @__PURE__ */ new Map();
      return n6.forEach(function(r6) {
        null !== r6.data.x && null !== r6.data.y && (e8.has(r6.x) ? e8.get(r6.x).push(r6) : e8.set(r6.x, [r6]));
      }), Array.from(e8.entries()).sort(function(e9, r6) {
        return e9[0] - r6[0];
      }).map(function(e9, r6, i6) {
        var n7, a4 = e9[0], s3 = e9[1], l3 = i6[r6 - 1], u2 = i6[r6 + 1];
        return { id: a4, x0: n7 = l3 ? a4 - (a4 - l3[0]) / 2 : a4, x: a4, y0: 0, y: 0, width: u2 ? a4 - n7 + (u2[0] - a4) / 2 : t7 - n7, height: o4, points: s3.reverse() };
      });
    }
    if ("y" === i5) {
      var r5 = /* @__PURE__ */ new Map();
      return n6.forEach(function(e9) {
        null !== e9.data.x && null !== e9.data.y && (r5.has(e9.y) ? r5.get(e9.y).push(e9) : r5.set(e9.y, [e9]));
      }), Array.from(r5.entries()).sort(function(e9, r6) {
        return e9[0] - r6[0];
      }).map(function(e9, r6, i6) {
        var n7, a4, s3 = e9[0], l3 = e9[1], u2 = i6[r6 - 1], d2 = i6[r6 + 1];
        return n7 = u2 ? s3 - (s3 - u2[0]) / 2 : s3, a4 = d2 ? s3 - n7 + (d2[0] - s3) / 2 : o4 - n7, { id: s3, x0: 0, x: 0, y0: n7, y: s3, width: t7, height: a4, points: l3.reverse() };
      });
    }
  }, [i5, n6]);
};
var be = function(e7) {
  var t7 = e7.data, o4 = e7.xScale, a4 = void 0 === o4 ? ce.xScale : o4, s3 = e7.xFormat, l3 = e7.yScale, d2 = void 0 === l3 ? ce.yScale : l3, c2 = e7.yFormat, f4 = e7.width, p5 = e7.height, h3 = e7.colors, b5 = void 0 === h3 ? ce.colors : h3, g5 = e7.curve, m3 = void 0 === g5 ? ce.curve : g5, v5 = e7.areaBaselineValue, x4 = void 0 === v5 ? ce.areaBaselineValue : v5, R = e7.pointColor, q = void 0 === R ? ce.pointColor : R, O4 = e7.pointBorderColor, S4 = void 0 === O4 ? ce.pointBorderColor : O4, C3 = e7.enableSlices, T4 = void 0 === C3 ? ce.enableSlicesTooltip : C3, M = Xt(s3), w4 = Xt(c2), W3 = dr(b5, "id"), G = Vt(), L2 = We(q, G), P4 = We(S4, G), j2 = (0, import_react9.useState)([]), F = j2[0], V3 = j2[1], E2 = (0, import_react9.useMemo)(function() {
    return dn(t7.filter(function(e8) {
      return -1 === F.indexOf(e8.id);
    }), a4, d2, f4, p5);
  }, [t7, F, a4, d2, f4, p5]), Y4 = E2.xScale, D = E2.yScale, X4 = E2.series, z2 = (0, import_react9.useMemo)(function() {
    var e8 = t7.map(function(e9) {
      return { id: e9.id, label: e9.id, color: W3(e9) };
    }), r5 = e8.map(function(e9) {
      return ie({}, X4.find(function(r6) {
        return r6.id === e9.id;
      }), { color: e9.color });
    }).filter(function(e9) {
      return Boolean(e9.id);
    });
    return { legendData: e8.map(function(e9) {
      return ie({}, e9, { hidden: !r5.find(function(r6) {
        return r6.id === e9.id;
      }) });
    }).reverse(), series: r5 };
  }, [t7, X4, W3]), A2 = z2.legendData, H2 = z2.series, I = (0, import_react9.useCallback)(function(e8) {
    V3(function(r5) {
      return r5.indexOf(e8) > -1 ? r5.filter(function(r6) {
        return r6 !== e8;
      }) : [].concat(r5, [e8]);
    });
  }, []), K3 = function(e8) {
    var i5 = e8.series, n6 = e8.getPointColor, t8 = e8.getPointBorderColor, o5 = e8.formatX, a5 = e8.formatY;
    return (0, import_react9.useMemo)(function() {
      return i5.reduce(function(e9, r5) {
        return [].concat(e9, r5.data.filter(function(e10) {
          return null !== e10.position.x && null !== e10.position.y;
        }).map(function(i6, s4) {
          var l4 = { id: r5.id + "." + s4, index: e9.length + s4, serieId: r5.id, serieColor: r5.color, x: i6.position.x, y: i6.position.y };
          return l4.color = n6(r5), l4.borderColor = t8(l4), l4.data = ie({}, i6.data, { xFormatted: o5(i6.data.x), yFormatted: a5(i6.data.y) }), l4;
        }));
      }, []);
    }, [i5, n6, t8, o5, a5]);
  }({ series: H2, getPointColor: L2, getPointBorderColor: P4, formatX: M, formatY: w4 }), N3 = ye({ enableSlices: T4, points: K3, width: f4, height: p5 });
  return { legendData: A2, toggleSerie: I, lineGenerator: pe({ curve: m3 }), areaGenerator: he({ curve: m3, yScale: D, areaBaselineValue: x4 }), getColor: W3, series: H2, xScale: Y4, yScale: D, slices: N3, points: K3 };
};
var ge = function(e7) {
  var r5 = e7.areaBlendMode, i5 = e7.areaOpacity, n6 = e7.color, t7 = e7.fill, o4 = e7.path, a4 = tt(), s3 = a4.animate, l3 = a4.config, u2 = it(o4), d2 = useSpring({ color: n6, config: l3, immediate: !s3 });
  return (0, import_jsx_runtime5.jsx)(animated.path, { d: u2, fill: t7 || d2.color, fillOpacity: i5, strokeWidth: 0, style: { mixBlendMode: r5 } });
};
ge.propTypes = { areaBlendMode: Mt.isRequired, areaOpacity: import_prop_types4.default.number.isRequired, color: import_prop_types4.default.string, fill: import_prop_types4.default.string, path: import_prop_types4.default.string.isRequired };
var me = function(e7) {
  var r5 = e7.areaGenerator, i5 = e7.areaOpacity, n6 = e7.areaBlendMode, t7 = e7.lines.slice(0).reverse();
  return (0, import_jsx_runtime5.jsx)("g", { children: t7.map(function(e8) {
    return (0, import_jsx_runtime5.jsx)(ge, ie({ path: r5(e8.data.map(function(e9) {
      return e9.position;
    })) }, ie({ areaOpacity: i5, areaBlendMode: n6 }, e8)), e8.id);
  }) });
};
me.propTypes = { areaGenerator: import_prop_types4.default.func.isRequired, areaOpacity: import_prop_types4.default.number.isRequired, areaBlendMode: Mt.isRequired, lines: import_prop_types4.default.arrayOf(import_prop_types4.default.object).isRequired };
var ve = (0, import_react9.memo)(me);
var xe = function(e7) {
  var i5 = e7.lineGenerator, n6 = e7.points, t7 = e7.color, o4 = e7.thickness, a4 = (0, import_react9.useMemo)(function() {
    return i5(n6);
  }, [i5, n6]), s3 = it(a4);
  return (0, import_jsx_runtime5.jsx)(animated.path, { d: s3, fill: "none", strokeWidth: o4, stroke: t7 });
};
xe.propTypes = { points: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ x: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]), y: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]) })), lineGenerator: import_prop_types4.default.func.isRequired, color: import_prop_types4.default.string.isRequired, thickness: import_prop_types4.default.number.isRequired };
var Re2 = (0, import_react9.memo)(xe);
var qe2 = function(e7) {
  var r5 = e7.lines, i5 = e7.lineGenerator, n6 = e7.lineWidth;
  return r5.slice(0).reverse().map(function(e8) {
    var r6 = e8.id, t7 = e8.data, o4 = e8.color;
    return (0, import_jsx_runtime5.jsx)(Re2, { id: r6, points: t7.map(function(e9) {
      return e9.position;
    }), lineGenerator: i5, color: o4, thickness: n6 }, r6);
  });
};
qe2.propTypes = { lines: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ id: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]).isRequired, color: import_prop_types4.default.string.isRequired, data: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ data: import_prop_types4.default.shape({ x: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number, import_prop_types4.default.instanceOf(Date)]), y: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number, import_prop_types4.default.instanceOf(Date)]) }).isRequired, position: import_prop_types4.default.shape({ x: import_prop_types4.default.number, y: import_prop_types4.default.number }).isRequired })).isRequired })).isRequired, lineWidth: import_prop_types4.default.number.isRequired, lineGenerator: import_prop_types4.default.func.isRequired };
var Oe2 = (0, import_react9.memo)(qe2);
var Se2 = function(e7) {
  var r5 = e7.slice, i5 = e7.axis, o4 = e7.debug, a4 = e7.tooltip, s3 = e7.isCurrent, l3 = e7.setCurrent, u2 = k3(), d2 = u2.showTooltipFromEvent, c2 = u2.hideTooltip, f4 = (0, import_react9.useCallback)(function(e8) {
    d2((0, import_react9.createElement)(a4, { slice: r5, axis: i5 }), e8, "right"), l3(r5);
  }, [d2, a4, r5]), p5 = (0, import_react9.useCallback)(function(e8) {
    d2((0, import_react9.createElement)(a4, { slice: r5, axis: i5 }), e8, "right");
  }, [d2, a4, r5]), h3 = (0, import_react9.useCallback)(function() {
    c2(), l3(null);
  }, [c2]);
  return (0, import_jsx_runtime5.jsx)("rect", { x: r5.x0, y: r5.y0, width: r5.width, height: r5.height, stroke: "red", strokeWidth: o4 ? 1 : 0, strokeOpacity: 0.75, fill: "red", fillOpacity: s3 && o4 ? 0.35 : 0, onMouseEnter: f4, onMouseMove: p5, onMouseLeave: h3 });
};
Se2.propTypes = { slice: import_prop_types4.default.object.isRequired, axis: import_prop_types4.default.oneOf(["x", "y"]).isRequired, debug: import_prop_types4.default.bool.isRequired, height: import_prop_types4.default.number.isRequired, tooltip: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]), isCurrent: import_prop_types4.default.bool.isRequired, setCurrent: import_prop_types4.default.func.isRequired };
var Ce2 = (0, import_react9.memo)(Se2);
var Te2 = function(e7) {
  var r5 = e7.slices, i5 = e7.axis, n6 = e7.debug, t7 = e7.height, o4 = e7.tooltip, a4 = e7.current, s3 = e7.setCurrent;
  return r5.map(function(e8) {
    return (0, import_jsx_runtime5.jsx)(Ce2, { slice: e8, axis: i5, debug: n6, height: t7, tooltip: o4, setCurrent: s3, isCurrent: null !== a4 && a4.id === e8.id }, e8.id);
  });
};
Te2.propTypes = { slices: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({ id: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string, import_prop_types4.default.instanceOf(Date)]).isRequired, x: import_prop_types4.default.number.isRequired, y: import_prop_types4.default.number.isRequired, points: import_prop_types4.default.arrayOf(import_prop_types4.default.object).isRequired })).isRequired, axis: import_prop_types4.default.oneOf(["x", "y"]).isRequired, debug: import_prop_types4.default.bool.isRequired, height: import_prop_types4.default.number.isRequired, tooltip: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]).isRequired, current: import_prop_types4.default.object, setCurrent: import_prop_types4.default.func.isRequired };
var Me2 = (0, import_react9.memo)(Te2);
var we2 = function(e7) {
  var r5 = e7.points, i5 = e7.symbol, n6 = e7.size, t7 = e7.borderWidth, o4 = e7.enableLabel, a4 = e7.label, s3 = e7.labelYOffset, l3 = Vt(), d2 = Ei(a4), c2 = r5.reverse().map(function(e8) {
    return { id: e8.id, x: e8.x, y: e8.y, datum: e8.data, fill: e8.color, stroke: e8.borderColor, label: o4 ? d2(e8.data) : null };
  });
  return (0, import_jsx_runtime5.jsx)("g", { children: c2.map(function(e8) {
    return (0, import_jsx_runtime5.jsx)(Mi, { x: e8.x, y: e8.y, datum: e8.datum, symbol: i5, size: n6, color: e8.fill, borderWidth: t7, borderColor: e8.stroke, label: e8.label, labelYOffset: s3, theme: l3 }, e8.id);
  }) });
};
we2.propTypes = { points: import_prop_types4.default.arrayOf(import_prop_types4.default.object), symbol: import_prop_types4.default.func, size: import_prop_types4.default.number.isRequired, color: import_prop_types4.default.func.isRequired, borderWidth: import_prop_types4.default.number.isRequired, borderColor: import_prop_types4.default.func.isRequired, enableLabel: import_prop_types4.default.bool.isRequired, label: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.func]).isRequired, labelYOffset: import_prop_types4.default.number };
var Be2 = (0, import_react9.memo)(we2);
var ke = function(e7) {
  var r5 = e7.points, i5 = e7.width, o4 = e7.height, a4 = e7.margin, s3 = e7.setCurrent, l3 = e7.onMouseEnter, u2 = e7.onMouseMove, d2 = e7.onMouseLeave, c2 = e7.onClick, f4 = e7.tooltip, p5 = e7.debug, h3 = k3(), y3 = h3.showTooltipAt, b5 = h3.hideTooltip, g5 = (0, import_react9.useCallback)(function(e8, r6) {
    y3((0, import_react9.createElement)(f4, { point: e8 }), [e8.x + a4.left, e8.y + a4.top], "top"), s3(e8), l3 && l3(e8, r6);
  }, [s3, y3, f4, l3, a4]), m3 = (0, import_react9.useCallback)(function(e8, r6) {
    y3((0, import_react9.createElement)(f4, { point: e8 }), [e8.x + a4.left, e8.y + a4.top], "top"), s3(e8), u2 && u2(e8, r6);
  }, [s3, y3, f4, u2]), v5 = (0, import_react9.useCallback)(function(e8, r6) {
    b5(), s3(null), d2 && d2(e8, r6);
  }, [b5, s3, d2]), x4 = (0, import_react9.useCallback)(function(e8, r6) {
    c2 && c2(e8, r6);
  }, [c2]);
  return (0, import_jsx_runtime5.jsx)(P3, { nodes: r5, width: i5, height: o4, onMouseEnter: g5, onMouseMove: m3, onMouseLeave: v5, onClick: x4, debug: p5 });
};
ke.propTypes = { points: import_prop_types4.default.arrayOf(import_prop_types4.default.object).isRequired, width: import_prop_types4.default.number.isRequired, height: import_prop_types4.default.number.isRequired, margin: import_prop_types4.default.object.isRequired, setCurrent: import_prop_types4.default.func.isRequired, onMouseEnter: import_prop_types4.default.func, onMouseMove: import_prop_types4.default.func, onMouseLeave: import_prop_types4.default.func, onClick: import_prop_types4.default.func, tooltip: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]).isRequired, debug: import_prop_types4.default.bool.isRequired };
var We2 = (0, import_react9.memo)(ke);
var Ge2 = function(e7) {
  var r5 = e7.data, n6 = e7.xScale, t7 = e7.xFormat, a4 = e7.yScale, s3 = e7.yFormat, l3 = e7.layers, d2 = e7.curve, c2 = e7.areaBaselineValue, f4 = e7.colors, p5 = e7.margin, h3 = e7.width, y3 = e7.height, b5 = e7.axisTop, g5 = e7.axisRight, m3 = e7.axisBottom, v5 = e7.axisLeft, x4 = e7.enableGridX, C3 = e7.enableGridY, T4 = e7.gridXValues, M = e7.gridYValues, w4 = e7.lineWidth, B3 = e7.enableArea, W3 = e7.areaOpacity, P4 = e7.areaBlendMode, j2 = e7.enablePoints, F = e7.pointSymbol, E2 = e7.pointSize, Y4 = e7.pointColor, D = e7.pointBorderWidth, X4 = e7.pointBorderColor, z2 = e7.enablePointLabel, H2 = e7.pointLabel, I = e7.pointLabelYOffset, J2 = e7.defs, K3 = e7.fill, Q3 = e7.markers, U = e7.legends, Z = e7.isInteractive, $2 = e7.useMesh, _2 = e7.debugMesh, ee = e7.onMouseEnter, re = e7.onMouseMove, ne2 = e7.onMouseLeave, te2 = e7.onClick, oe2 = e7.tooltip, ae2 = e7.enableSlices, se2 = e7.debugSlices, le2 = e7.sliceTooltip, ue2 = e7.enableCrosshair, de2 = e7.crosshairType, ce2 = e7.role, fe2 = At(h3, y3, p5), pe2 = fe2.margin, he2 = fe2.innerWidth, ye2 = fe2.innerHeight, ge2 = fe2.outerWidth, me2 = fe2.outerHeight, xe2 = be({ data: r5, xScale: n6, xFormat: t7, yScale: a4, yFormat: s3, width: he2, height: ye2, colors: f4, curve: d2, areaBaselineValue: c2, pointColor: Y4, pointBorderColor: X4, enableSlices: ae2 }), Re3 = xe2.legendData, qe3 = xe2.toggleSerie, Se3 = xe2.lineGenerator, Ce3 = xe2.areaGenerator, Te3 = xe2.series, we3 = xe2.xScale, ke2 = xe2.yScale, Ge3 = xe2.slices, Le3 = xe2.points, Pe3 = Vt(), je2 = We(Y4, Pe3), Fe3 = We(X4, Pe3), Ve3 = (0, import_react9.useState)(null), Ee2 = Ve3[0], Ye2 = Ve3[1], De2 = (0, import_react9.useState)(null), Xe2 = De2[0], ze2 = De2[1], Ae = { grid: (0, import_jsx_runtime5.jsx)(B, { theme: Pe3, width: he2, height: ye2, xScale: x4 ? we3 : null, yScale: C3 ? ke2 : null, xValues: T4, yValues: M }, "grid"), markers: (0, import_jsx_runtime5.jsx)(Bi, { markers: Q3, width: he2, height: ye2, xScale: we3, yScale: ke2, theme: Pe3 }, "markers"), axes: (0, import_jsx_runtime5.jsx)(X2, { xScale: we3, yScale: ke2, width: he2, height: ye2, theme: Pe3, top: b5, right: g5, bottom: m3, left: v5 }, "axes"), areas: null, lines: (0, import_jsx_runtime5.jsx)(Oe2, { lines: Te3, lineGenerator: Se3, lineWidth: w4 }, "lines"), slices: null, points: null, crosshair: null, mesh: null, legends: U.map(function(e8, r6) {
    return (0, import_jsx_runtime5.jsx)(X3, ie({}, e8, { containerWidth: he2, containerHeight: ye2, data: e8.data || Re3, theme: Pe3, toggleSerie: e8.toggleSerie ? qe3 : void 0 }), "legend." + r6);
  }) }, He2 = rn(J2, Te3, K3);
  return B3 && (Ae.areas = (0, import_jsx_runtime5.jsx)(ve, { areaGenerator: Ce3, areaOpacity: W3, areaBlendMode: P4, lines: Te3 }, "areas")), Z && false !== ae2 && (Ae.slices = (0, import_jsx_runtime5.jsx)(Me2, { slices: Ge3, axis: ae2, debug: se2, height: ye2, tooltip: le2, current: Xe2, setCurrent: ze2 }, "slices")), j2 && (Ae.points = (0, import_jsx_runtime5.jsx)(Be2, { points: Le3, symbol: F, size: E2, color: je2, borderWidth: D, borderColor: Fe3, enableLabel: z2, label: H2, labelYOffset: I }, "points")), Z && ue2 && (null !== Ee2 && (Ae.crosshair = (0, import_jsx_runtime5.jsx)(P2, { width: he2, height: ye2, x: Ee2.x, y: Ee2.y, type: de2 }, "crosshair")), null !== Xe2 && (Ae.crosshair = (0, import_jsx_runtime5.jsx)(P2, { width: he2, height: ye2, x: Xe2.x, y: Xe2.y, type: ae2 }, "crosshair"))), Z && $2 && false === ae2 && (Ae.mesh = (0, import_jsx_runtime5.jsx)(We2, { points: Le3, width: he2, height: ye2, margin: pe2, current: Ee2, setCurrent: Ye2, onMouseEnter: ee, onMouseMove: re, onMouseLeave: ne2, onClick: te2, tooltip: oe2, debug: _2 }, "mesh")), (0, import_jsx_runtime5.jsx)(Si, { defs: He2, width: ge2, height: me2, margin: pe2, role: ce2, children: l3.map(function(r6, i5) {
    return "function" == typeof r6 ? (0, import_jsx_runtime5.jsx)(import_react9.Fragment, { children: r6(ie({}, e7, { innerWidth: he2, innerHeight: ye2, series: Te3, slices: Ge3, points: Le3, xScale: we3, yScale: ke2, lineGenerator: Se3, areaGenerator: Ce3, currentPoint: Ee2, setCurrentPoint: Ye2, currentSlice: Xe2, setCurrentSlice: ze2 })) }, i5) : Ae[r6];
  }) });
};
Ge2.propTypes = le, Ge2.defaultProps = ce;
var Le2 = Fi(Ge2);
var Pe2 = function(e7) {
  return (0, import_jsx_runtime5.jsx)(ti, { children: function(r5) {
    var i5 = r5.width, n6 = r5.height;
    return (0, import_jsx_runtime5.jsx)(Le2, ie({ width: i5, height: n6 }, e7));
  } });
};
var je = function(e7) {
  var r5 = e7.width, o4 = e7.height, a4 = e7.margin, d2 = e7.pixelRatio, c2 = e7.data, f4 = e7.xScale, p5 = e7.xFormat, h3 = e7.yScale, y3 = e7.yFormat, b5 = e7.curve, g5 = e7.layers, m3 = e7.colors, v5 = e7.lineWidth, x4 = e7.enableArea, q = e7.areaBaselineValue, O4 = e7.areaOpacity, S4 = e7.enablePoints, C3 = e7.pointSize, w4 = e7.pointColor, B3 = e7.pointBorderWidth, k5 = e7.pointBorderColor, W3 = e7.enableGridX, G = e7.gridXValues, L2 = e7.enableGridY, F = e7.gridYValues, V3 = e7.axisTop, Y4 = e7.axisRight, D = e7.axisBottom, X4 = e7.axisLeft, A2 = e7.legends, H2 = e7.isInteractive, I = e7.debugMesh, J2 = e7.onMouseLeave, K3 = e7.onClick, Q3 = e7.tooltip, U = e7.canvasRef, Z = (0, import_react9.useRef)(null), $2 = At(r5, o4, a4), ne2 = $2.margin, te2 = $2.innerWidth, oe2 = $2.innerHeight, ae2 = $2.outerWidth, se2 = $2.outerHeight, le2 = Vt(), ue2 = (0, import_react9.useState)(null), de2 = ue2[0], ce2 = ue2[1], fe2 = be({ data: c2, xScale: f4, xFormat: p5, yScale: h3, yFormat: y3, width: te2, height: oe2, colors: m3, curve: b5, areaBaselineValue: q, pointColor: w4, pointBorderColor: k5 }), pe2 = fe2.lineGenerator, he2 = fe2.areaGenerator, ye2 = fe2.series, ge2 = fe2.xScale, me2 = fe2.yScale, ve2 = fe2.points, xe2 = x3({ points: ve2, width: te2, height: oe2, debug: I }), Re3 = xe2.delaunay, qe3 = xe2.voronoi;
  (0, import_react9.useEffect)(function() {
    U && (U.current = Z.current), Z.current.width = ae2 * d2, Z.current.height = se2 * d2;
    var e8 = Z.current.getContext("2d");
    e8.scale(d2, d2), e8.fillStyle = le2.background, e8.fillRect(0, 0, ae2, se2), e8.translate(ne2.left, ne2.top), g5.forEach(function(r6) {
      if ("function" == typeof r6 && r6({ ctx: e8, innerWidth: te2, innerHeight: oe2, series: ye2, points: ve2, xScale: ge2, yScale: me2, lineWidth: v5, lineGenerator: pe2, areaGenerator: he2, currentPoint: de2, setCurrentPoint: ce2 }), "grid" === r6 && le2.grid.line.strokeWidth > 0 && (e8.lineWidth = le2.grid.line.strokeWidth, e8.strokeStyle = le2.grid.line.stroke, W3 && C(e8, { width: te2, height: oe2, scale: ge2, axis: "x", values: G }), L2 && C(e8, { width: te2, height: oe2, scale: me2, axis: "y", values: F })), "axes" === r6 && V(e8, { xScale: ge2, yScale: me2, width: te2, height: oe2, top: V3, right: Y4, bottom: D, left: X4, theme: le2 }), "areas" === r6 && true === x4 && (e8.save(), e8.globalAlpha = O4, he2.context(e8), ye2.forEach(function(r7) {
        e8.fillStyle = r7.color, e8.beginPath(), he2(r7.data.map(function(e9) {
          return e9.position;
        })), e8.fill();
      }), e8.restore()), "lines" === r6 && (pe2.context(e8), ye2.forEach(function(r7) {
        e8.strokeStyle = r7.color, e8.lineWidth = v5, e8.beginPath(), pe2(r7.data.map(function(e9) {
          return e9.position;
        })), e8.stroke();
      })), "points" === r6 && true === S4 && C3 > 0 && ve2.forEach(function(r7) {
        e8.fillStyle = r7.color, e8.beginPath(), e8.arc(r7.x, r7.y, C3 / 2, 0, 2 * Math.PI), e8.fill(), B3 > 0 && (e8.strokeStyle = r7.borderColor, e8.lineWidth = B3, e8.stroke());
      }), "mesh" === r6 && true === I && (O3(e8, qe3), de2 && S3(e8, qe3, de2.index)), "legends" === r6) {
        var i5 = ye2.map(function(e9) {
          return { id: e9.id, label: e9.id, color: e9.color };
        }).reverse();
        A2.forEach(function(r7) {
          H(e8, ie({}, r7, { data: r7.data || i5, containerWidth: te2, containerHeight: oe2, theme: le2 }));
        });
      }
    });
  }, [Z, ae2, se2, g5, le2, pe2, ye2, ge2, me2, W3, G, L2, F, V3, Y4, D, X4, A2, ve2, S4, C3, de2]);
  var Oe3 = (0, import_react9.useCallback)(function(e8) {
    var r6 = Qi(Z.current, e8), i5 = r6[0], n6 = r6[1];
    if (!Ji(ne2.left, ne2.top, te2, oe2, i5, n6))
      return null;
    var t7 = Re3.find(i5 - ne2.left, n6 - ne2.top);
    return ve2[t7];
  }, [Z, ne2, te2, oe2, Re3]), Se3 = k3(), Ce3 = Se3.showTooltipFromEvent, Te3 = Se3.hideTooltip, Me3 = (0, import_react9.useCallback)(function(e8) {
    var r6 = Oe3(e8);
    ce2(r6), r6 ? Ce3((0, import_react9.createElement)(Q3, { point: r6 }), e8) : Te3();
  }, [Oe3, ce2, Ce3, Te3, Q3]), we3 = (0, import_react9.useCallback)(function(e8) {
    Te3(), ce2(null), de2 && J2 && J2(de2, e8);
  }, [Te3, ce2, J2]), Be3 = (0, import_react9.useCallback)(function(e8) {
    if (K3) {
      var r6 = Oe3(e8);
      r6 && K3(r6, e8);
    }
  }, [Oe3, K3]);
  return (0, import_jsx_runtime5.jsx)("canvas", { ref: Z, width: ae2 * d2, height: se2 * d2, style: { width: ae2, height: se2, cursor: H2 ? "auto" : "normal" }, onMouseEnter: H2 ? Me3 : void 0, onMouseMove: H2 ? Me3 : void 0, onMouseLeave: H2 ? we3 : void 0, onClick: H2 ? Be3 : void 0 });
};
je.propTypes = ue, je.defaultProps = fe;
var Fe2 = Fi(je);
var Ve2 = (0, import_react9.forwardRef)(function(e7, r5) {
  return (0, import_jsx_runtime5.jsx)(Fe2, ie({}, e7, { canvasRef: r5 }));
});
var Ee = (0, import_react9.forwardRef)(function(e7, r5) {
  return (0, import_jsx_runtime5.jsx)(ti, { children: function(i5) {
    var n6 = i5.width, t7 = i5.height;
    return (0, import_jsx_runtime5.jsx)(Ve2, ie({ width: n6, height: t7 }, e7, { ref: r5 }));
  } });
});
export {
  Le2 as Line,
  Ve2 as LineCanvas,
  fe as LineCanvasDefaultProps,
  ue as LineCanvasPropTypes,
  ce as LineDefaultProps,
  le as LinePropTypes,
  Pe2 as ResponsiveLine,
  Ee as ResponsiveLineCanvas,
  he as useAreaGenerator,
  be as useLine,
  pe as useLineGenerator,
  ye as useSlices
};
//# sourceMappingURL=@nivo_line.js.map
