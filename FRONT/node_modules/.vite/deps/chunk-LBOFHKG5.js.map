{
  "version": 3,
  "sources": ["../../@nivo/colors/src/schemes/categorical.ts", "../../@nivo/colors/src/schemes/diverging.ts", "../../@nivo/colors/src/schemes/sequential.ts", "../../@nivo/colors/src/schemes/all.ts", "../../@nivo/colors/src/schemes/cyclical.ts", "../../@nivo/colors/src/schemes/interpolators.ts", "../../@nivo/colors/src/inheritedColor.ts", "../../@nivo/colors/src/props.ts", "../../@nivo/colors/src/scales/sequentialColorScale.ts", "../../@nivo/colors/src/scales/divergingColorScale.ts", "../../@nivo/colors/src/scales/quantizeColorScale.ts", "../../@nivo/colors/src/scales/continuousColorScale.ts", "../../@nivo/colors/src/scales/ordinalColorScale.ts", "../../@nivo/legends/src/svg/symbols/SymbolCircle.tsx", "../../@nivo/legends/src/svg/symbols/SymbolDiamond.tsx", "../../@nivo/legends/src/svg/symbols/SymbolSquare.tsx", "../../@nivo/legends/src/svg/symbols/SymbolTriangle.tsx", "../../@nivo/legends/src/defaults.ts", "../../@nivo/legends/src/compute.ts", "../../@nivo/legends/src/svg/ContinuousColorsLegendSvg.tsx", "../../@nivo/legends/src/svg/AnchoredContinuousColorsLegendSvg.tsx", "../../@nivo/legends/src/svg/LegendSvgItem.tsx", "../../@nivo/legends/src/svg/LegendSvg.tsx", "../../@nivo/legends/src/svg/BoxLegendSvg.tsx", "../../@nivo/legends/src/canvas.ts", "../../@nivo/legends/src/hooks.ts", "../../@nivo/legends/src/props.ts"],
  "sourcesContent": ["import {\n    schemeCategory10,\n    schemeAccent,\n    schemeDark2,\n    schemePaired,\n    schemePastel1,\n    schemePastel2,\n    schemeSet1,\n    schemeSet2,\n    schemeSet3,\n} from 'd3-scale-chromatic'\n\nexport const categoricalColorSchemes = {\n    nivo: ['#e8c1a0', '#f47560', '#f1e15b', '#e8a838', '#61cdbb', '#97e3d5'],\n    category10: schemeCategory10,\n    accent: schemeAccent,\n    dark2: schemeDark2,\n    paired: schemePaired,\n    pastel1: schemePastel1,\n    pastel2: schemePastel2,\n    set1: schemeSet1,\n    set2: schemeSet2,\n    set3: schemeSet3,\n}\n\nexport type CategoricalColorSchemeId = keyof typeof categoricalColorSchemes\n\nexport const categoricalColorSchemeIds = Object.keys(\n    categoricalColorSchemes\n) as CategoricalColorSchemeId[]\n", "import {\n    schemeBrBG,\n    interpolateBrBG,\n    schemePRGn,\n    interpolatePRGn,\n    schemePiYG,\n    interpolatePiYG,\n    schemePuOr,\n    interpolatePuOr,\n    schemeRdBu,\n    interpolateRdBu,\n    schemeRdGy,\n    interpolateRdGy,\n    schemeRdYlBu,\n    interpolateRdYlBu,\n    schemeRdYlGn,\n    interpolateRdYlGn,\n    schemeSpectral,\n    interpolateSpectral,\n} from 'd3-scale-chromatic'\n\n// Diverging color schemes support a size k ranging from 3 to 11\nexport const divergingColorSchemes = {\n    brown_blueGreen: schemeBrBG,\n    purpleRed_green: schemePRGn,\n    pink_yellowGreen: schemePiYG,\n    purple_orange: schemePuOr,\n    red_blue: schemeRdBu,\n    red_grey: schemeRdGy,\n    red_yellow_blue: schemeRdYlBu,\n    red_yellow_green: schemeRdYlGn,\n    spectral: schemeSpectral,\n}\n\nexport type DivergingColorSchemeId = keyof typeof divergingColorSchemes\n\nexport const divergingColorSchemeIds = Object.keys(\n    divergingColorSchemes\n) as DivergingColorSchemeId[]\n\nexport const divergingColorInterpolators = {\n    brown_blueGreen: interpolateBrBG,\n    purpleRed_green: interpolatePRGn,\n    pink_yellowGreen: interpolatePiYG,\n    purple_orange: interpolatePuOr,\n    red_blue: interpolateRdBu,\n    red_grey: interpolateRdGy,\n    red_yellow_blue: interpolateRdYlBu,\n    red_yellow_green: interpolateRdYlGn,\n    spectral: interpolateSpectral,\n}\n\nexport type DivergingColorInterpolatorId = keyof typeof divergingColorInterpolators\n", "import {\n    // single hue\n    schemeBlues,\n    interpolateBlues,\n    schemeGreens,\n    interpolateGreens,\n    schemeGreys,\n    interpolateGreys,\n    schemeOranges,\n    interpolateOranges,\n    schemePurples,\n    interpolatePurples,\n    schemeReds,\n    interpolateReds,\n    // multi hue\n    schemeBuGn,\n    interpolateBuGn,\n    schemeBuPu,\n    interpolateBuPu,\n    schemeGnBu,\n    interpolateGnBu,\n    schemeOrRd,\n    interpolateOrRd,\n    schemePuBuGn,\n    interpolatePuBuGn,\n    schemePuBu,\n    interpolatePuBu,\n    schemePuRd,\n    interpolatePuRd,\n    schemeRdPu,\n    interpolateRdPu,\n    schemeYlGnBu,\n    interpolateYlGnBu,\n    schemeYlGn,\n    interpolateYlGn,\n    schemeYlOrBr,\n    interpolateYlOrBr,\n    schemeYlOrRd,\n    interpolateYlOrRd,\n    interpolateTurbo,\n    interpolateViridis,\n    interpolateInferno,\n    interpolateMagma,\n    interpolatePlasma,\n    interpolateCividis,\n    interpolateWarm,\n    interpolateCool,\n    interpolateCubehelixDefault,\n} from 'd3-scale-chromatic'\n\n// Sequential, single-hue color schemes support a size k ranging from 3 to 9\n// Sequential, multi-hue color schemes support a size k ranging from 3 to 9\nexport const sequentialColorSchemes = {\n    // single hue\n    blues: schemeBlues,\n    greens: schemeGreens,\n    greys: schemeGreys,\n    oranges: schemeOranges,\n    purples: schemePurples,\n    reds: schemeReds,\n    // multi hue\n    blue_green: schemeBuGn,\n    blue_purple: schemeBuPu,\n    green_blue: schemeGnBu,\n    orange_red: schemeOrRd,\n    purple_blue_green: schemePuBuGn,\n    purple_blue: schemePuBu,\n    purple_red: schemePuRd,\n    red_purple: schemeRdPu,\n    yellow_green_blue: schemeYlGnBu,\n    yellow_green: schemeYlGn,\n    yellow_orange_brown: schemeYlOrBr,\n    yellow_orange_red: schemeYlOrRd,\n}\n\nexport type SequentialColorSchemeId = keyof typeof sequentialColorSchemes\n\nexport const sequentialColorSchemeIds = Object.keys(\n    sequentialColorSchemes\n) as SequentialColorSchemeId[]\n\nexport const sequentialColorInterpolators = {\n    // single hue\n    blues: interpolateBlues,\n    greens: interpolateGreens,\n    greys: interpolateGreys,\n    oranges: interpolateOranges,\n    purples: interpolatePurples,\n    reds: interpolateReds,\n    // multi hue\n    turbo: interpolateTurbo,\n    viridis: interpolateViridis,\n    inferno: interpolateInferno,\n    magma: interpolateMagma,\n    plasma: interpolatePlasma,\n    cividis: interpolateCividis,\n    warm: interpolateWarm,\n    cool: interpolateCool,\n    cubehelixDefault: interpolateCubehelixDefault,\n    blue_green: interpolateBuGn,\n    blue_purple: interpolateBuPu,\n    green_blue: interpolateGnBu,\n    orange_red: interpolateOrRd,\n    purple_blue_green: interpolatePuBuGn,\n    purple_blue: interpolatePuBu,\n    purple_red: interpolatePuRd,\n    red_purple: interpolateRdPu,\n    yellow_green_blue: interpolateYlGnBu,\n    yellow_green: interpolateYlGn,\n    yellow_orange_brown: interpolateYlOrBr,\n    yellow_orange_red: interpolateYlOrRd,\n}\n\nexport type SequentialColorInterpolatorId = keyof typeof sequentialColorInterpolators\n", "import {\n    categoricalColorSchemes,\n    categoricalColorSchemeIds,\n    CategoricalColorSchemeId,\n} from './categorical'\nimport { divergingColorSchemes, divergingColorSchemeIds, DivergingColorSchemeId } from './diverging'\nimport {\n    sequentialColorSchemes,\n    sequentialColorSchemeIds,\n    SequentialColorSchemeId,\n} from './sequential'\n\nexport const colorSchemes = {\n    ...categoricalColorSchemes,\n    ...divergingColorSchemes,\n    ...sequentialColorSchemes,\n}\n\nexport type ColorSchemeId =\n    | CategoricalColorSchemeId\n    | DivergingColorSchemeId\n    | SequentialColorSchemeId\n\nexport const colorSchemeIds = Object.keys(colorSchemes) as ColorSchemeId[]\n\nexport const isCategoricalColorScheme = (\n    scheme: ColorSchemeId\n): scheme is CategoricalColorSchemeId =>\n    categoricalColorSchemeIds.includes(scheme as CategoricalColorSchemeId)\n\nexport const isDivergingColorScheme = (scheme: ColorSchemeId): scheme is DivergingColorSchemeId =>\n    divergingColorSchemeIds.includes(scheme as DivergingColorSchemeId)\n\nexport const isSequentialColorScheme = (scheme: ColorSchemeId): scheme is SequentialColorSchemeId =>\n    sequentialColorSchemeIds.includes(scheme as SequentialColorSchemeId)\n", "import { interpolateRainbow, interpolateSinebow } from 'd3-scale-chromatic'\n\nexport const cyclicalColorInterpolators = {\n    rainbow: interpolateRainbow,\n    sinebow: interpolateSinebow,\n}\n\nexport type CyclicalColorInterpolatorId = keyof typeof cyclicalColorInterpolators\n", "import { divergingColorInterpolators, DivergingColorInterpolatorId } from './diverging'\nimport { sequentialColorInterpolators, SequentialColorInterpolatorId } from './sequential'\nimport { cyclicalColorInterpolators, CyclicalColorInterpolatorId } from './cyclical'\n\nexport const colorInterpolators = {\n    ...divergingColorInterpolators,\n    ...sequentialColorInterpolators,\n    ...cyclicalColorInterpolators,\n}\n\nexport type ColorInterpolatorId =\n    | DivergingColorInterpolatorId\n    | SequentialColorInterpolatorId\n    | CyclicalColorInterpolatorId\n\nexport const colorInterpolatorIds = Object.keys(colorInterpolators) as ColorInterpolatorId[]\n", "import { useMemo } from 'react'\nimport { get, isPlainObject } from 'lodash'\nimport { rgb, RGBColor } from 'd3-color'\nimport { Theme } from '@nivo/core'\n\nexport type ColorModifierBrightness = ['brighter', number]\n\nexport type ColorModifierDarkness = ['darker', number]\n\nexport type ColorModifierOpacity = ['opacity', number]\n\nexport type ColorModifier = ColorModifierBrightness | ColorModifierDarkness | ColorModifierOpacity\n\nexport type ColorModifierFunction = (color: RGBColor) => RGBColor\n\nexport type InheritedColorConfigStaticColor = string\n\nexport type InheritedColorConfigCustomFunction<Datum> = (d: Datum, ...drest: Datum[]) => string\n\nexport interface InheritedColorConfigFromTheme {\n    theme: string\n}\n\nexport interface InheritedColorConfigFromContext {\n    from: string\n    modifiers?: ColorModifier[]\n}\n\nexport type InheritedColorConfig<Datum> =\n    | InheritedColorConfigStaticColor\n    | InheritedColorConfigCustomFunction<Datum>\n    | InheritedColorConfigFromTheme\n    | InheritedColorConfigFromContext\n\nconst isInheritedColorConfigFromTheme = <Datum>(\n    config: InheritedColorConfig<Datum>\n): config is InheritedColorConfigFromTheme => {\n    return (config as InheritedColorConfigFromTheme).theme !== undefined\n}\n\nconst isInheritedColorConfigFromContext = <Datum>(\n    config: InheritedColorConfig<Datum>\n): config is InheritedColorConfigFromContext => {\n    return (config as InheritedColorConfigFromContext).from !== undefined\n}\n\n/**\n * Create a color generator for items which\n * might inherit from parent context,\n * for example labels, outlinesâ€¦\n *\n * Support the following strategies:\n * - custom function\n * - color from theme\n * - color from parent, with optional color modifiers\n * - static color\n */\nexport const getInheritedColorGenerator = <Datum = any>(\n    config: InheritedColorConfig<Datum>,\n    theme?: Theme\n) => {\n    // user provided function\n    if (typeof config === 'function') {\n        return config\n    }\n\n    if (isPlainObject(config)) {\n        // use color from theme\n        if (isInheritedColorConfigFromTheme(config)) {\n            if (theme === undefined) {\n                throw new Error(`Unable to use color from theme as no theme was provided`)\n            }\n\n            const themeColor = get(theme, config.theme)\n            if (themeColor === undefined) {\n                throw new Error(`Color from theme is undefined at path: '${config.theme}'`)\n            }\n\n            return () => themeColor\n        }\n\n        // use color from parent with optional color modifiers\n        if (isInheritedColorConfigFromContext(config)) {\n            const getColor = (d: Datum) => get(d, config.from)\n\n            if (Array.isArray(config.modifiers)) {\n                const modifiers: ColorModifierFunction[] = []\n                for (const modifier of config.modifiers) {\n                    const [modifierType, amount] = modifier\n                    if (modifierType === 'brighter') {\n                        modifiers.push(color => color.brighter(amount))\n                    } else if (modifierType === 'darker') {\n                        modifiers.push(color => color.darker(amount))\n                    } else if (modifierType === 'opacity') {\n                        modifiers.push(color => {\n                            color.opacity = amount\n\n                            return color\n                        })\n                    } else {\n                        throw new Error(\n                            `Invalid color modifier: '${modifierType}', must be one of: 'brighter', 'darker', 'opacity'`\n                        )\n                    }\n                }\n\n                if (modifiers.length === 0) return getColor\n\n                return (datum: Datum) =>\n                    modifiers\n                        .reduce((color, modify) => modify(color), rgb(getColor(datum)))\n                        .toString()\n            }\n\n            // no modifier\n            return getColor\n        }\n\n        throw new Error(\n            `Invalid color spec, you should either specify 'theme' or 'from' when using a config object`\n        )\n    }\n\n    // use provided color statically\n    return () => config as string\n}\n\nexport const useInheritedColor = <Datum = any>(\n    config: InheritedColorConfig<Datum>,\n    theme?: Theme\n) => useMemo(() => getInheritedColorGenerator<Datum>(config, theme), [config, theme])\n", "import PropTypes from 'prop-types'\nimport { colorSchemeIds } from './schemes'\n\nexport const ordinalColorsPropType = PropTypes.oneOfType([\n    PropTypes.func,\n    PropTypes.arrayOf(PropTypes.string),\n    PropTypes.shape({\n        scheme: PropTypes.oneOf(colorSchemeIds).isRequired,\n        size: PropTypes.number,\n    }),\n    PropTypes.shape({\n        datum: PropTypes.string.isRequired,\n    }),\n    PropTypes.string,\n])\n\nexport const inheritedColorPropType = PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.func,\n    PropTypes.shape({\n        theme: PropTypes.string.isRequired,\n    }),\n    PropTypes.shape({\n        from: PropTypes.string.isRequired,\n        modifiers: PropTypes.arrayOf(PropTypes.array),\n    }),\n])\n", "import { useMemo } from 'react'\nimport { scaleSequential } from 'd3-scale'\nimport { colorInterpolators, ColorInterpolatorId } from '../schemes'\n\nexport interface SequentialColorScaleBaseConfig {\n    type: 'sequential'\n    minValue?: number\n    maxValue?: number\n}\n\nexport interface SequentialColorScaleSchemeConfig extends SequentialColorScaleBaseConfig {\n    scheme?: ColorInterpolatorId\n}\n\nexport interface SequentialColorScaleColorsConfig extends SequentialColorScaleBaseConfig {\n    colors: [string, string]\n}\n\nexport interface SequentialColorScaleInterpolatorConfig extends SequentialColorScaleBaseConfig {\n    interpolator: (t: number) => string\n}\n\nexport type SequentialColorScaleConfig =\n    | SequentialColorScaleSchemeConfig\n    | SequentialColorScaleColorsConfig\n    | SequentialColorScaleInterpolatorConfig\n\nexport interface SequentialColorScaleValues {\n    min: number\n    max: number\n}\n\nexport const sequentialColorScaleDefaults: {\n    scheme: ColorInterpolatorId\n} = {\n    scheme: 'turbo',\n}\n\nexport const getSequentialColorScale = (\n    config: SequentialColorScaleConfig,\n    values: SequentialColorScaleValues\n) => {\n    const { minValue, maxValue } = config\n    const min = minValue !== undefined ? minValue : values.min\n    const max = maxValue !== undefined ? maxValue : values.max\n\n    const colorScale = scaleSequential<string>().domain([min, max]).clamp(true)\n    if ('colors' in config) {\n        colorScale.range(config.colors)\n    } else if ('interpolator' in config) {\n        colorScale.interpolator(config.interpolator)\n    } else {\n        const scheme = config.scheme ?? sequentialColorScaleDefaults.scheme\n        colorScale.interpolator(colorInterpolators[scheme])\n    }\n\n    return colorScale\n}\n\nexport const useSequentialColorScale = (\n    config: SequentialColorScaleConfig,\n    values: SequentialColorScaleValues\n) => useMemo(() => getSequentialColorScale(config, values), [config, values])\n", "import { useMemo } from 'react'\nimport { scaleDiverging } from 'd3-scale'\nimport { colorInterpolators, ColorInterpolatorId } from '../schemes'\n\ninterface DivergingColorScaleBaseConfig {\n    type: 'diverging'\n    minValue?: number\n    maxValue?: number\n    divergeAt?: number\n}\n\nexport interface DivergingColorScaleSchemeConfig extends DivergingColorScaleBaseConfig {\n    scheme?: ColorInterpolatorId\n}\n\nexport interface DivergingColorScaleColorsConfig extends DivergingColorScaleBaseConfig {\n    colors: [string, string, string]\n}\n\nexport interface DivergingColorScaleInterpolatorConfig extends DivergingColorScaleBaseConfig {\n    interpolator: (t: number) => string\n}\n\nexport type DivergingColorScaleConfig =\n    | DivergingColorScaleSchemeConfig\n    | DivergingColorScaleColorsConfig\n    | DivergingColorScaleInterpolatorConfig\n\nexport interface DivergingColorScaleValues {\n    min: number\n    max: number\n}\n\nexport const divergingColorScaleDefaults: {\n    scheme: ColorInterpolatorId\n    divergeAt: number\n} = {\n    scheme: 'red_yellow_blue',\n    divergeAt: 0.5,\n}\n\nexport const getDivergingColorScale = (\n    config: DivergingColorScaleConfig,\n    values: DivergingColorScaleValues\n) => {\n    const { minValue, maxValue } = config\n    const min = minValue !== undefined ? minValue : values.min\n    const max = maxValue !== undefined ? maxValue : values.max\n    const domain = [min, min + (max - min) / 2, max]\n\n    const divergeAt = config.divergeAt ?? divergingColorScaleDefaults.divergeAt\n    const offset = 0.5 - divergeAt\n\n    const colorScale = scaleDiverging<string>().domain(domain).clamp(true)\n    let interpolator = (t: number) => String(t) as string\n    if ('colors' in config) {\n        interpolator = scaleDiverging<string>()\n            .domain(domain.map(x => x - offset * (max - min)))\n            .range(config.colors)\n            .interpolator()\n    } else if ('interpolator' in config) {\n        interpolator = config.interpolator\n    } else {\n        const scheme = config.scheme ?? divergingColorScaleDefaults.scheme\n        interpolator = colorInterpolators[scheme]\n    }\n    const offsetInterpolator = (t: number) => interpolator(t + offset)\n    return colorScale.interpolator(offsetInterpolator)\n}\n\nexport const useDivergingColorScale = (\n    config: DivergingColorScaleConfig,\n    values: DivergingColorScaleValues\n) => useMemo(() => getDivergingColorScale(config, values), [config, values])\n", "import { useMemo } from 'react'\nimport { scaleQuantize } from 'd3-scale'\nimport { colorInterpolators, ColorInterpolatorId } from '../schemes'\n\n// colors from a scheme\nexport interface QuantizeColorScaleSchemeConfig {\n    type: 'quantize'\n    domain?: [number, number]\n    scheme?: ColorInterpolatorId\n    steps?: number\n}\n\n// explicit colors\nexport interface QuantizeColorScaleColorsConfig {\n    type: 'quantize'\n    domain?: [number, number]\n    colors: string[]\n}\n\nexport type QuantizeColorScaleConfig =\n    | QuantizeColorScaleSchemeConfig\n    | QuantizeColorScaleColorsConfig\n\nexport interface QuantizeColorScaleValues {\n    min: number\n    max: number\n}\n\nexport const quantizeColorScaleDefaults: {\n    scheme: ColorInterpolatorId\n    steps: NonNullable<QuantizeColorScaleSchemeConfig['steps']>\n} = {\n    scheme: 'turbo',\n    steps: 7,\n}\n\nexport const getQuantizeColorScale = (\n    config: QuantizeColorScaleConfig,\n    values: QuantizeColorScaleValues\n) => {\n    const colorScale = scaleQuantize<string>()\n        .domain(config.domain || [values.min, values.max])\n        .nice()\n\n    if ('colors' in config) {\n        colorScale.range(config.colors)\n    } else {\n        const scheme = config.scheme || quantizeColorScaleDefaults.scheme\n        const steps = config.steps === undefined ? quantizeColorScaleDefaults.steps : config.steps\n        const interpolator = colorInterpolators[scheme]\n        const colors = Array.from({ length: steps }).map((_, step) =>\n            interpolator(step * (1 / (steps - 1)))\n        )\n\n        colorScale.range(colors)\n    }\n\n    return colorScale\n}\n\nexport const useQuantizeColorScale = (\n    config: QuantizeColorScaleConfig,\n    values: QuantizeColorScaleValues\n) => useMemo(() => getQuantizeColorScale(config, values), [config, values])\n", "import { useMemo } from 'react'\nimport { ScaleDiverging, ScaleQuantize, ScaleSequential, scaleLinear } from 'd3-scale'\nimport {\n    SequentialColorScaleConfig,\n    SequentialColorScaleValues,\n    getSequentialColorScale,\n} from './sequentialColorScale'\nimport {\n    DivergingColorScaleConfig,\n    DivergingColorScaleValues,\n    getDivergingColorScale,\n} from './divergingColorScale'\nimport {\n    QuantizeColorScaleConfig,\n    QuantizeColorScaleValues,\n    getQuantizeColorScale,\n} from './quantizeColorScale'\n\nexport type ContinuousColorScaleConfig =\n    | SequentialColorScaleConfig\n    | DivergingColorScaleConfig\n    | QuantizeColorScaleConfig\n\nexport type ContinuousColorScaleValues =\n    | SequentialColorScaleValues\n    | DivergingColorScaleValues\n    | QuantizeColorScaleValues\n\nconst isSequentialColorScaleConfig = (\n    config: ContinuousColorScaleConfig\n): config is SequentialColorScaleConfig => config.type === 'sequential'\n\nconst isDivergingColorScaleConfig = (\n    config: ContinuousColorScaleConfig\n): config is DivergingColorScaleConfig => config.type === 'diverging'\n\nconst isQuantizeColorScaleConfig = (\n    config: ContinuousColorScaleConfig\n): config is QuantizeColorScaleConfig => config.type === 'quantize'\n\nexport const getContinuousColorScale = <Config extends ContinuousColorScaleConfig>(\n    config: Config,\n    values: ContinuousColorScaleValues\n) => {\n    if (isSequentialColorScaleConfig(config)) {\n        return getSequentialColorScale(config, values)\n    }\n\n    if (isDivergingColorScaleConfig(config)) {\n        return getDivergingColorScale(config, values)\n    }\n\n    if (isQuantizeColorScaleConfig(config)) {\n        return getQuantizeColorScale(config, values)\n    }\n\n    throw new Error('Invalid continuous color scale config')\n}\n\nexport const useContinuousColorScale = (\n    config: ContinuousColorScaleConfig,\n    values: ContinuousColorScaleValues\n) => useMemo(() => getContinuousColorScale(config, values), [config, values])\n\nexport const computeContinuousColorScaleColorStops = (\n    scale: ScaleSequential<string> | ScaleDiverging<string> | ScaleQuantize<string>,\n    steps = 16\n) => {\n    const domain = scale.domain()\n\n    // quantize\n    if ('thresholds' in scale) {\n        const stops: {\n            key: string\n            offset: number\n            stopColor: string\n        }[] = []\n\n        const normalizedScale = scaleLinear().domain(domain).range([0, 1])\n        scale.range().forEach((color, index) => {\n            const [start, end] = scale.invertExtent(color)\n\n            stops.push({\n                key: `${index}.0`,\n                offset: normalizedScale(start),\n                stopColor: color,\n            })\n            stops.push({\n                key: `${index}.1`,\n                offset: normalizedScale(end),\n                stopColor: color,\n            })\n        })\n\n        return stops\n    }\n\n    const colorStopsScale = scale.copy()\n    if (domain.length === 2) {\n        // sequential\n        colorStopsScale.domain([0, 1])\n    } else if (domain.length === 3) {\n        // diverging\n        colorStopsScale.domain([0, 0.5, 1])\n    }\n\n    return ((colorStopsScale as any).ticks(steps) as number[]).map((value: number) => ({\n        key: `${value}`,\n        offset: value,\n        stopColor: `${colorStopsScale(value)}`,\n    }))\n}\n", "import { useMemo } from 'react'\nimport { get, isPlainObject } from 'lodash'\nimport { scaleOrdinal } from 'd3-scale'\nimport {\n    ColorSchemeId,\n    colorSchemes,\n    isCategoricalColorScheme,\n    isSequentialColorScheme,\n    isDivergingColorScheme,\n} from '../schemes'\n\n/**\n * Static color.\n */\nexport type OrdinalColorScaleConfigStaticColor = string\n\n/**\n * User defined function, receiving the current datum.\n */\nexport type OrdinalColorScaleConfigCustomFunction<Datum> = (d: Datum) => string\n\n/**\n * Pre-defined color scheme.\n */\nexport interface OrdinalColorScaleConfigScheme {\n    scheme: ColorSchemeId\n    // size is useful for diverging & sequential colors,\n    // as they are array of array, whereas categorical colors\n    // are simple arrays, if the size isn't specified,\n    // the bigger array will be selected, this means the 11th\n    // for diverging colors and 9th for sequential ones.\n    size?: number\n}\n\n/**\n * User defined colors.\n */\nexport type OrdinalColorScaleConfigCustomColors = string[]\n\n/**\n * Get color from datum.\n */\nexport interface OrdinalColorScaleConfigDatumProperty {\n    // path to the color property\n    datum: string\n}\n\nexport type OrdinalColorScaleConfig<Datum = any> =\n    | OrdinalColorScaleConfigStaticColor\n    | OrdinalColorScaleConfigCustomFunction<Datum>\n    | OrdinalColorScaleConfigScheme\n    | OrdinalColorScaleConfigCustomColors\n    | OrdinalColorScaleConfigDatumProperty\n\nconst isOrdinalColorScaleConfigScheme = <Datum>(\n    config: OrdinalColorScaleConfig<Datum>\n): config is OrdinalColorScaleConfigScheme => {\n    return (config as OrdinalColorScaleConfigScheme).scheme !== undefined\n}\n\nconst isOrdinalColorScaleConfigDatumProperty = <Datum>(\n    config: OrdinalColorScaleConfig<Datum>\n): config is OrdinalColorScaleConfigDatumProperty => {\n    return (config as OrdinalColorScaleConfigDatumProperty).datum !== undefined\n}\n\nexport type DatumIdentityAccessor<Datum> = (datum: Datum) => string | number\n\nexport type OrdinalColorScale<Datum> = (d: Datum) => string\n\n/**\n * Compute an ordinal color scale\n */\nexport const getOrdinalColorScale = <Datum = any>(\n    config: OrdinalColorScaleConfig<Datum>,\n    identity?: string | DatumIdentityAccessor<Datum>\n): OrdinalColorScale<Datum> => {\n    // user defined function\n    if (typeof config === 'function') {\n        return config\n    }\n\n    // compute accessor to the datum identity\n    const getIdentity =\n        typeof identity === 'function' ? identity : (datum: Datum) => get(datum, identity as string)\n\n    // user defined color array\n    if (Array.isArray(config)) {\n        const scale = scaleOrdinal(config)\n        const generator = (datum: Datum) => scale(getIdentity(datum))\n        generator.scale = scale\n\n        return generator as OrdinalColorScale<Datum>\n    }\n\n    if (isPlainObject(config)) {\n        // use color from current datum\n        if (isOrdinalColorScaleConfigDatumProperty(config)) {\n            return (datum: Datum) => get(datum, config.datum)\n        }\n\n        // ordinal scale from predefined scheme\n        if (isOrdinalColorScaleConfigScheme(config)) {\n            // categorical color scheme\n            if (isCategoricalColorScheme(config.scheme)) {\n                const scale = scaleOrdinal(colorSchemes[config.scheme])\n                const generator = (datum: Datum) => scale(getIdentity(datum))\n                generator.scale = scale\n\n                return generator as OrdinalColorScale<Datum>\n            }\n\n            // Diverging color schemes support a size k ranging from 3 to 11\n            if (isDivergingColorScheme(config.scheme)) {\n                if (config.size !== undefined && (config.size < 3 || config.size > 11)) {\n                    throw new Error(\n                        `Invalid size '${config.size}' for diverging color scheme '${config.scheme}', must be between 3~11`\n                    )\n                }\n\n                const scale = scaleOrdinal(colorSchemes[config.scheme][config.size || 11])\n                const generator = (d: Datum) => scale(getIdentity(d))\n                generator.scale = scale\n\n                return generator as OrdinalColorScale<Datum>\n            }\n\n            // Sequential, single-hue color schemes support a size k ranging from 3 to 9.\n            // Sequential, multi-hue color schemes support a size k ranging from 3 to 9.\n            if (isSequentialColorScheme(config.scheme)) {\n                if (config.size !== undefined && (config.size < 3 || config.size > 9)) {\n                    throw new Error(\n                        `Invalid size '${config.size}' for sequential color scheme '${config.scheme}', must be between 3~9`\n                    )\n                }\n\n                const scale = scaleOrdinal(colorSchemes[config.scheme][config.size || 9])\n                const generator = (d: Datum) => scale(getIdentity(d))\n                generator.scale = scale\n\n                return generator as OrdinalColorScale<Datum>\n            }\n        }\n\n        throw new Error(\n            `Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property`\n        )\n    }\n\n    // static color\n    return () => config as string\n}\n\nexport const useOrdinalColorScale = <Datum = any>(\n    config: OrdinalColorScaleConfig<Datum>,\n    identity: string | DatumIdentityAccessor<Datum>\n) => useMemo(() => getOrdinalColorScale<Datum>(config, identity), [config, identity])\n", "import { SymbolProps } from './types'\n\nexport const SymbolCircle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <circle\n            r={size / 2}\n            cx={x + size / 2}\n            cy={y + size / 2}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolDiamond = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                    M${size / 2} 0\n                    L${size * 0.8} ${size / 2}\n                    L${size / 2} ${size}\n                    L${size * 0.2} ${size / 2}\n                    L${size / 2} 0\n                `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolSquare = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <rect\n            x={x}\n            y={y}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            width={size}\n            height={size}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolTriangle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                M${size / 2} 0\n                L${size} ${size}\n                L0 ${size}\n                L${size / 2} 0\n            `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n", "import { ContinuousColorsLegendProps } from './types'\n\nexport const continuousColorsLegendDefaults: {\n    length: NonNullable<ContinuousColorsLegendProps['length']>\n    thickness: NonNullable<ContinuousColorsLegendProps['thickness']>\n    direction: NonNullable<ContinuousColorsLegendProps['direction']>\n    tickPosition: NonNullable<ContinuousColorsLegendProps['tickPosition']>\n    tickSize: NonNullable<ContinuousColorsLegendProps['tickSize']>\n    tickSpacing: NonNullable<ContinuousColorsLegendProps['tickSpacing']>\n    tickOverlap: NonNullable<ContinuousColorsLegendProps['tickOverlap']>\n    tickFormat: NonNullable<ContinuousColorsLegendProps['tickFormat']>\n    titleAlign: NonNullable<ContinuousColorsLegendProps['titleAlign']>\n    titleOffset: NonNullable<ContinuousColorsLegendProps['titleOffset']>\n} = {\n    length: 200,\n    thickness: 16,\n    direction: 'row',\n    tickPosition: 'after',\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: false,\n    tickFormat: (value: number) => `${value}`,\n    titleAlign: 'start',\n    titleOffset: 4,\n}\n", "import { scaleLinear } from 'd3-scale'\nimport { getValueFormatter } from '@nivo/core'\nimport { computeContinuousColorScaleColorStops } from '@nivo/colors'\nimport {\n    BoxLegendSvgProps,\n    ContinuousColorsLegendProps,\n    LegendAnchor,\n    LegendItemDirection,\n} from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst isObject = <T>(item: unknown): item is T =>\n    typeof item === 'object' && !Array.isArray(item) && item !== null\n\nconst zeroPadding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n}\n\nexport const computeDimensions = ({\n    direction,\n    itemsSpacing,\n    padding: _padding,\n    itemCount,\n    itemWidth,\n    itemHeight,\n}: Pick<BoxLegendSvgProps, 'direction' | 'padding'> &\n    Record<'itemsSpacing' | 'itemCount' | 'itemWidth' | 'itemHeight', number>) => {\n    if (typeof _padding !== 'number' && !isObject(_padding)) {\n        throw new Error('Invalid property padding, must be one of: number, object')\n    }\n\n    const padding =\n        typeof _padding === 'number'\n            ? {\n                  top: _padding,\n                  right: _padding,\n                  bottom: _padding,\n                  left: _padding,\n              }\n            : {\n                  ...zeroPadding,\n                  ..._padding,\n              }\n\n    const horizontalPadding = padding.left + padding.right\n    const verticalPadding = padding.top + padding.bottom\n    let width = itemWidth + horizontalPadding\n    let height = itemHeight + verticalPadding\n    const spacing = (itemCount - 1) * itemsSpacing\n    if (direction === 'row') {\n        width = itemWidth * itemCount + spacing + horizontalPadding\n    } else if (direction === 'column') {\n        height = itemHeight * itemCount + spacing + verticalPadding\n    }\n\n    return { width, height, padding }\n}\n\nexport const computePositionFromAnchor = ({\n    anchor,\n    translateX,\n    translateY,\n    containerWidth,\n    containerHeight,\n    width,\n    height,\n}: { anchor: LegendAnchor } & Record<\n    'translateX' | 'translateY' | 'containerWidth' | 'containerHeight' | 'width' | 'height',\n    number\n>) => {\n    let x = translateX\n    let y = translateY\n\n    switch (anchor) {\n        case 'top':\n            x += (containerWidth - width) / 2\n            break\n\n        case 'top-right':\n            x += containerWidth - width\n            break\n\n        case 'right':\n            x += containerWidth - width\n            y += (containerHeight - height) / 2\n            break\n\n        case 'bottom-right':\n            x += containerWidth - width\n            y += containerHeight - height\n            break\n\n        case 'bottom':\n            x += (containerWidth - width) / 2\n            y += containerHeight - height\n            break\n\n        case 'bottom-left':\n            y += containerHeight - height\n            break\n\n        case 'left':\n            y += (containerHeight - height) / 2\n            break\n\n        case 'center':\n            x += (containerWidth - width) / 2\n            y += (containerHeight - height) / 2\n            break\n    }\n\n    return { x, y }\n}\n\nexport const computeItemLayout = ({\n    direction,\n    justify,\n    symbolSize,\n    symbolSpacing,\n    width,\n    height,\n}: {\n    direction: LegendItemDirection\n    justify: boolean\n} & Record<'symbolSize' | 'symbolSpacing' | 'width' | 'height', number>) => {\n    let symbolX\n    let symbolY\n\n    let labelX\n    let labelY\n    let labelAnchor: 'start' | 'middle' | 'end'\n    let labelAlignment: 'alphabetic' | 'central' | 'text-before-edge'\n\n    switch (direction) {\n        case 'left-to-right':\n            symbolX = 0\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = width\n                labelAnchor = 'end'\n            } else {\n                labelX = symbolSize + symbolSpacing\n                labelAnchor = 'start'\n            }\n            break\n\n        case 'right-to-left':\n            symbolX = width - symbolSize\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = 0\n                labelAnchor = 'start'\n            } else {\n                labelX = width - symbolSize - symbolSpacing\n                labelAnchor = 'end'\n            }\n            break\n\n        case 'top-to-bottom':\n            symbolX = (width - symbolSize) / 2\n            symbolY = 0\n\n            labelX = width / 2\n\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = height\n                labelAlignment = 'alphabetic'\n            } else {\n                labelY = symbolSize + symbolSpacing\n                labelAlignment = 'text-before-edge'\n            }\n            break\n\n        case 'bottom-to-top':\n            symbolX = (width - symbolSize) / 2\n            symbolY = height - symbolSize\n\n            labelX = width / 2\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = 0\n                labelAlignment = 'text-before-edge'\n            } else {\n                labelY = height - symbolSize - symbolSpacing\n                labelAlignment = 'alphabetic'\n            }\n            break\n    }\n\n    return {\n        symbolX,\n        symbolY,\n        labelX,\n        labelY,\n        labelAnchor,\n        labelAlignment,\n    }\n}\n\nexport const computeContinuousColorsLegend = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    // left to right for `row`, bottom to top for `column`\n    const domain = direction === 'column' ? [...scale.domain()].reverse() : scale.domain()\n\n    const positionScale = scaleLinear().domain(domain)\n    if (domain.length === 2) {\n        // sequential, quantize\n        positionScale.range([0, length])\n    } else if (domain.length === 3) {\n        // diverging\n        positionScale.range([0, length / 2, length])\n    }\n\n    let values: number[]\n    if ('thresholds' in scale) {\n        // quantize\n        values = [domain[0], ...scale.thresholds(), domain[1]]\n    } else {\n        // sequential, diverging\n        values = Array.isArray(ticks) ? ticks : (scale as any).ticks(ticks)\n    }\n\n    const colorStops = computeContinuousColorScaleColorStops(scale, 32)\n\n    const formatValue = getValueFormatter(tickFormat)\n\n    const computedTicks: {\n        x1: number\n        y1: number\n        x2: number\n        y2: number\n        text: string\n        textX: number\n        textY: number\n        textHorizontalAlign: 'start' | 'middle' | 'end'\n        textVerticalAlign: 'alphabetic' | 'central' | 'hanging'\n    }[] = []\n\n    let width: number\n    let height: number\n\n    const gradientX1 = 0\n    let gradientY1 = 0\n    let gradientX2 = 0\n    const gradientY2 = 0\n\n    let titleX: number\n    let titleY: number\n    let titleRotation: number\n    let titleVerticalAlign: 'alphabetic' | 'hanging'\n\n    if (direction === 'row') {\n        width = length\n        height = thickness\n\n        gradientX2 = 1\n\n        let y1: number\n        let y2: number\n\n        let textY: number\n        const textHorizontalAlign = 'middle'\n        let textVerticalAlign: 'alphabetic' | 'hanging'\n\n        titleRotation = 0\n        if (titleAlign === 'start') {\n            titleX = 0\n        } else if (titleAlign === 'middle') {\n            titleX = length / 2\n        } else {\n            titleX = length\n        }\n\n        if (tickPosition === 'before') {\n            y1 = -tickSize\n            y2 = tickOverlap ? thickness : 0\n\n            textY = -tickSize - tickSpacing\n            textVerticalAlign = 'alphabetic'\n\n            titleY = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            y1 = tickOverlap ? 0 : thickness\n            y2 = thickness + tickSize\n\n            textY = y2 + tickSpacing\n            textVerticalAlign = 'hanging'\n\n            titleY = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const x = positionScale(value)\n\n            computedTicks.push({\n                x1: x,\n                y1,\n                x2: x,\n                y2,\n                text: formatValue(value),\n                textX: x,\n                textY,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    } else {\n        width = thickness\n        height = length\n\n        gradientY1 = 1\n\n        let x1: number\n        let x2: number\n\n        let textX: number\n        let textHorizontalAlign: 'start' | 'end'\n        const textVerticalAlign = 'central'\n\n        titleRotation = -90\n        if (titleAlign === 'start') {\n            titleY = length\n        } else if (titleAlign === 'middle') {\n            titleY = length / 2\n        } else {\n            titleY = 0\n        }\n\n        if (tickPosition === 'before') {\n            x1 = -tickSize\n            x2 = tickOverlap ? thickness : 0\n\n            textX = x1 - tickSpacing\n            textHorizontalAlign = 'end'\n\n            titleX = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            x1 = tickOverlap ? 0 : thickness\n            x2 = thickness + tickSize\n\n            textX = x2 + tickSpacing\n            textHorizontalAlign = 'start'\n\n            titleX = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const y = positionScale(value)\n\n            computedTicks.push({\n                x1,\n                y1: y,\n                x2,\n                y2: y,\n                text: formatValue(value),\n                textX,\n                textY: y,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    }\n\n    return {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks: computedTicks,\n        titleText: title,\n        titleX,\n        titleY,\n        titleRotation,\n        titleHorizontalAlign: titleAlign,\n        titleVerticalAlign,\n    }\n}\n", "import { Fragment } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { computeContinuousColorsLegend } from '../compute'\nimport { ContinuousColorsLegendProps } from '../types'\nimport { continuousColorsLegendDefaults } from '../defaults'\n\nexport const ContinuousColorsLegendSvg = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        ticks: computedTicks,\n        colorStops,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const theme = useTheme()\n\n    const id = `ContinuousColorsLegendSvgGradient.${direction}.${colorStops\n        .map(stop => stop.offset)\n        .join('_')}`\n\n    return (\n        <g>\n            <defs>\n                <linearGradient\n                    id={id}\n                    x1={gradientX1}\n                    y1={gradientY1}\n                    x2={gradientX2}\n                    y2={gradientY2}\n                >\n                    {colorStops.map(colorStop => (\n                        <stop {...colorStop} />\n                    ))}\n                </linearGradient>\n            </defs>\n            {titleText && (\n                <text\n                    transform={`translate(${titleX}, ${titleY}) rotate(${titleRotation})`}\n                    textAnchor={titleHorizontalAlign}\n                    dominantBaseline={titleVerticalAlign}\n                    style={theme.legends.title.text}\n                >\n                    {titleText}\n                </text>\n            )}\n            <rect width={width} height={height} fill={`url(#${id}`} />\n            {computedTicks.map((tick, index) => (\n                <Fragment key={index}>\n                    <line\n                        x1={tick.x1}\n                        y1={tick.y1}\n                        x2={tick.x2}\n                        y2={tick.y2}\n                        style={theme.legends.ticks.line}\n                    />\n                    <text\n                        x={tick.textX}\n                        y={tick.textY}\n                        textAnchor={tick.textHorizontalAlign}\n                        dominantBaseline={tick.textVerticalAlign}\n                        style={theme.legends.ticks.text}\n                    >\n                        {tick.text}\n                    </text>\n                </Fragment>\n            ))}\n        </g>\n    )\n}\n", "import { AnchoredContinuousColorsLegendProps } from '../types'\nimport { computePositionFromAnchor } from '../compute'\nimport { continuousColorsLegendDefaults } from '../defaults'\nimport { ContinuousColorsLegendSvg } from './ContinuousColorsLegendSvg'\n\nexport const AnchoredContinuousColorsLegendSvg = ({\n    containerWidth,\n    containerHeight,\n    anchor,\n    translateX = 0,\n    translateY = 0,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    ...legendProps\n}: AnchoredContinuousColorsLegendProps) => {\n    let width: number\n    let height: number\n    if (direction === 'row') {\n        width = length\n        height = thickness\n    } else {\n        width = thickness\n        height = length\n    }\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <g transform={`translate(${x}, ${y})`}>\n            <ContinuousColorsLegendSvg\n                length={length}\n                thickness={thickness}\n                direction={direction}\n                {...legendProps}\n            />\n        </g>\n    )\n}\n", "import { useState, useCallback } from 'react'\nimport * as React from 'react'\nimport { useTheme } from '@nivo/core'\nimport { LegendSvgItemProps } from '../types'\nimport { computeItemLayout } from '../compute'\nimport { SymbolCircle, SymbolDiamond, SymbolSquare, SymbolTriangle } from './symbols'\n\ntype Style = Partial<{\n    itemBackground: string\n    itemOpacity: number\n    itemTextColor: string\n    symbolBorderColor: string\n    symbolBorderWidth: number\n    symbolSize: number\n}>\n\nconst symbolByShape = {\n    circle: SymbolCircle,\n    diamond: SymbolDiamond,\n    square: SymbolSquare,\n    triangle: SymbolTriangle,\n}\n\nexport const LegendSvgItem = ({\n    x,\n    y,\n    width,\n    height,\n    data,\n    direction = 'left-to-right',\n    justify = false,\n    textColor,\n    background = 'transparent',\n    opacity = 1,\n\n    symbolShape = 'square',\n    symbolSize = 16,\n    symbolSpacing = 8,\n    symbolBorderWidth = 0,\n    symbolBorderColor = 'transparent',\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: LegendSvgItemProps) => {\n    const [style, setStyle] = useState<Style>({})\n    const theme = useTheme()\n\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on === 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseEnter?.(data, event)\n        },\n        [onMouseEnter, data, effects]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on !== 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseLeave?.(data, event)\n        },\n        [onMouseLeave, data, effects]\n    )\n\n    const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout({\n        direction,\n        justify,\n        symbolSize: style.symbolSize ?? symbolSize,\n        symbolSpacing,\n        width,\n        height,\n    })\n\n    const isInteractive = [onClick, onMouseEnter, onMouseLeave, toggleSerie].some(\n        handler => handler !== undefined\n    )\n\n    const SymbolShape = typeof symbolShape === 'function' ? symbolShape : symbolByShape[symbolShape]\n\n    return (\n        <g\n            transform={`translate(${x},${y})`}\n            style={{\n                opacity: style.itemOpacity ?? opacity,\n            }}\n        >\n            <rect\n                width={width}\n                height={height}\n                fill={style.itemBackground ?? background}\n                style={{\n                    cursor: isInteractive ? 'pointer' : 'auto',\n                }}\n                onClick={event => {\n                    onClick?.(data, event)\n                    toggleSerie?.(data.id)\n                }}\n                onMouseEnter={handleMouseEnter}\n                onMouseLeave={handleMouseLeave}\n            />\n            {React.createElement(SymbolShape, {\n                id: data.id,\n                x: symbolX,\n                y: symbolY,\n                size: style.symbolSize ?? symbolSize,\n                fill: data.fill ?? data.color ?? 'black',\n                borderWidth: style.symbolBorderWidth ?? symbolBorderWidth,\n                borderColor: style.symbolBorderColor ?? symbolBorderColor,\n                ...(data.hidden ? theme.legends.hidden.symbol : undefined),\n            })}\n            <text\n                textAnchor={labelAnchor}\n                style={{\n                    ...theme.legends.text,\n                    fill: style.itemTextColor ?? textColor ?? theme.legends.text.fill ?? 'black',\n                    dominantBaseline: labelAlignment,\n                    pointerEvents: 'none',\n                    userSelect: 'none',\n                    ...(data.hidden ? theme.legends.hidden.text : undefined),\n                }}\n                x={labelX}\n                y={labelY}\n            >\n                {data.label}\n            </text>\n        </g>\n    )\n}\n", "import { LegendSvgItem } from './LegendSvgItem'\nimport { LegendSvgProps } from '../types'\nimport { computeDimensions } from '../compute'\n\nexport const LegendSvg = ({\n    data,\n\n    x,\n    y,\n    direction,\n    padding: _padding = 0,\n    justify,\n    effects,\n\n    itemWidth,\n    itemHeight,\n    itemDirection = 'left-to-right',\n    itemsSpacing = 0,\n    itemTextColor,\n    itemBackground = 'transparent',\n    itemOpacity = 1,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n}: LegendSvgProps) => {\n    const { padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    return (\n        <g transform={`translate(${x},${y})`}>\n            {data.map((data, i) => (\n                <LegendSvgItem\n                    key={i}\n                    data={data}\n                    x={i * xStep + padding.left}\n                    y={i * yStep + padding.top}\n                    width={itemWidth}\n                    height={itemHeight}\n                    direction={itemDirection}\n                    justify={justify}\n                    effects={effects}\n                    textColor={itemTextColor}\n                    background={itemBackground}\n                    opacity={itemOpacity}\n                    symbolShape={symbolShape}\n                    symbolSize={symbolSize}\n                    symbolSpacing={symbolSpacing}\n                    symbolBorderWidth={symbolBorderWidth}\n                    symbolBorderColor={symbolBorderColor}\n                    onClick={onClick}\n                    onMouseEnter={onMouseEnter}\n                    onMouseLeave={onMouseLeave}\n                    toggleSerie={toggleSerie}\n                />\n            ))}\n        </g>\n    )\n}\n", "import { LegendSvg } from './LegendSvg'\nimport { BoxLegendSvgProps } from '../types'\nimport { computeDimensions, computePositionFromAnchor } from '../compute'\n\nexport const BoxLegendSvg = ({\n    data,\n\n    containerWidth,\n    containerHeight,\n    translateX = 0,\n    translateY = 0,\n    anchor,\n    direction,\n    padding = 0,\n    justify,\n\n    itemsSpacing = 0,\n    itemWidth,\n    itemHeight,\n    itemDirection,\n    itemTextColor,\n    itemBackground,\n    itemOpacity,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: BoxLegendSvgProps) => {\n    const { width, height } = computeDimensions({\n        itemCount: data.length,\n        itemsSpacing,\n        itemWidth,\n        itemHeight,\n        direction,\n        padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <LegendSvg\n            data={data}\n            x={x}\n            y={y}\n            direction={direction}\n            padding={padding}\n            justify={justify}\n            effects={effects}\n            itemsSpacing={itemsSpacing}\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            itemDirection={itemDirection}\n            itemTextColor={itemTextColor}\n            itemBackground={itemBackground}\n            itemOpacity={itemOpacity}\n            symbolShape={symbolShape}\n            symbolSize={symbolSize}\n            symbolSpacing={symbolSpacing}\n            symbolBorderWidth={symbolBorderWidth}\n            symbolBorderColor={symbolBorderColor}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            toggleSerie={typeof toggleSerie === 'boolean' ? undefined : toggleSerie}\n        />\n    )\n}\n", "import { CompleteTheme, degreesToRadians } from '@nivo/core'\nimport {\n    computeDimensions,\n    computePositionFromAnchor,\n    computeItemLayout,\n    computeContinuousColorsLegend,\n} from './compute'\nimport { AnchoredContinuousColorsLegendProps, LegendCanvasProps } from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst textAlignMapping = {\n    start: 'left',\n    middle: 'center',\n    end: 'right',\n} as const\n\nexport const renderLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        data,\n\n        containerWidth,\n        containerHeight,\n        translateX = 0,\n        translateY = 0,\n        anchor,\n        direction,\n        padding: _padding = 0,\n        justify = false,\n\n        // items\n        itemsSpacing = 0,\n        itemWidth,\n        itemHeight,\n        itemDirection = 'left-to-right',\n        itemTextColor,\n\n        // symbol\n        symbolSize = 16,\n        symbolSpacing = 8,\n        // @todo add support for shapes\n        // symbolShape = LegendSvgItem.defaultProps.symbolShape,\n\n        theme,\n    }: LegendCanvasProps\n) => {\n    const { width, height, padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `${theme.legends.text.fontSize}px ${theme.legends.text.fontFamily || 'sans-serif'}`\n\n    data.forEach((d, i) => {\n        const itemX = i * xStep + padding.left\n        const itemY = i * yStep + padding.top\n\n        const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout(\n            {\n                direction: itemDirection,\n                justify,\n                symbolSize,\n                symbolSpacing,\n                width: itemWidth,\n                height: itemHeight,\n            }\n        )\n\n        ctx.fillStyle = d.color ?? 'black'\n        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize)\n\n        ctx.textAlign = textAlignMapping[labelAnchor]\n\n        if (labelAlignment === 'central') {\n            ctx.textBaseline = 'middle'\n        }\n\n        ctx.fillStyle = itemTextColor ?? theme.legends.text.fill ?? 'black'\n        ctx.fillText(String(d.label), itemX + labelX, itemY + labelY)\n    })\n\n    ctx.restore()\n}\n\nexport const renderContinuousColorLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        containerWidth,\n        containerHeight,\n        anchor,\n        translateX = 0,\n        translateY = 0,\n        scale,\n        length = continuousColorsLegendDefaults.length,\n        thickness = continuousColorsLegendDefaults.thickness,\n        direction = continuousColorsLegendDefaults.direction,\n        ticks: _ticks,\n        tickPosition = continuousColorsLegendDefaults.tickPosition,\n        tickSize = continuousColorsLegendDefaults.tickSize,\n        tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n        tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n        tickFormat = continuousColorsLegendDefaults.tickFormat,\n        title,\n        titleAlign = continuousColorsLegendDefaults.titleAlign,\n        titleOffset = continuousColorsLegendDefaults.titleOffset,\n        theme,\n    }: AnchoredContinuousColorsLegendProps & {\n        theme: CompleteTheme\n    }\n) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks: _ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const initialStyles = {\n        font: ctx.font,\n        textAlign: ctx.textAlign,\n        textBaseline: ctx.textBaseline,\n    }\n    ctx.save()\n\n    ctx.translate(x, y)\n\n    const gradient = ctx.createLinearGradient(\n        gradientX1 * width,\n        gradientY1 * height,\n        gradientX2 * width,\n        gradientY2 * height\n    )\n    colorStops.forEach(colorStop => {\n        gradient.addColorStop(colorStop.offset, colorStop.stopColor)\n    })\n\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n\n    ctx.font = `${\n        theme.legends.ticks.text.fontWeight ? `${theme.legends.ticks.text.fontWeight} ` : ''\n    }${theme.legends.ticks.text.fontSize}px ${theme.legends.ticks.text.fontFamily}`\n\n    ticks.forEach(tick => {\n        if ((theme.legends.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n            ctx.lineCap = 'square'\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x1, tick.y1)\n            ctx.lineTo(tick.x2, tick.y2)\n            ctx.stroke()\n        }\n\n        if (theme.legends.ticks.text.fill) {\n            ctx.fillStyle = theme.legends.ticks.text.fill\n        }\n        ctx.textAlign = tick.textHorizontalAlign === 'middle' ? 'center' : tick.textHorizontalAlign\n        ctx.textBaseline = tick.textVerticalAlign === 'central' ? 'middle' : tick.textVerticalAlign\n\n        ctx.fillText(tick.text, tick.textX, tick.textY)\n    })\n\n    if (titleText) {\n        ctx.save()\n        ctx.translate(titleX, titleY)\n        ctx.rotate(degreesToRadians(titleRotation))\n\n        ctx.font = `${\n            theme.legends.title.text.fontWeight ? `${theme.legends.title.text.fontWeight} ` : ''\n        }${theme.legends.title.text.fontSize}px ${theme.legends.title.text.fontFamily}`\n        if (theme.legends.title.text.fill) {\n            ctx.fillStyle = theme.legends.title.text.fill\n        }\n        ctx.textAlign = titleHorizontalAlign === 'middle' ? 'center' : titleHorizontalAlign\n        ctx.textBaseline = titleVerticalAlign\n\n        ctx.fillText(titleText, 0, 0)\n\n        ctx.restore()\n    }\n\n    ctx.restore()\n\n    ctx.font = initialStyles.font\n    ctx.textAlign = initialStyles.textAlign\n    ctx.textBaseline = initialStyles.textBaseline\n}\n", "import { useMemo } from 'react'\n\ntype Scale = {\n    (value: number): number\n    invertExtent: (value: number) => [number, number]\n    range: () => number[]\n}\n\nexport const useQuantizeColorScaleLegendData = ({\n    scale,\n    domain: overriddenDomain,\n    reverse = false,\n    valueFormat = v => v,\n    separator = ' - ',\n}: {\n    scale: Scale\n    domain?: number[]\n    reverse?: boolean\n    valueFormat?: <T, U>(value: T) => T | U\n    separator?: string\n}) => {\n    return useMemo(() => {\n        const domain = overriddenDomain ?? scale.range()\n\n        const items = domain.map((domainValue, index) => {\n            const [start, end] = scale.invertExtent(domainValue)\n\n            return {\n                id: domainValue,\n                index,\n                extent: [start, end],\n                label: `${valueFormat(start)}${separator}${valueFormat(end)}`,\n                value: scale(start),\n                color: domainValue,\n            }\n        })\n\n        if (reverse) items.reverse()\n\n        return items\n    }, [overriddenDomain, scale, reverse, separator, valueFormat])\n}\n", "import PropTypes from 'prop-types'\n\n/**\n * The prop type is exported as a simple object instead of `PropTypes.shape`\n * to be able to add extra properties.\n *\n * @example\n * ```javascript\n * import { LegendPropShape } from '@nivo/legends'\n *\n * const customLegendPropType = PropTypes.shape({\n *     ...LegendPropShape,\n *     extra: PropTypes.any.isRequired,\n * })\n * ```\n */\nexport const LegendPropShape = {\n    data: PropTypes.arrayOf(PropTypes.object),\n\n    // position & layout\n    anchor: PropTypes.oneOf([\n        'top',\n        'top-right',\n        'right',\n        'bottom-right',\n        'bottom',\n        'bottom-left',\n        'left',\n        'top-left',\n        'center',\n    ]).isRequired,\n    translateX: PropTypes.number,\n    translateY: PropTypes.number,\n    direction: PropTypes.oneOf(['row', 'column']).isRequired,\n\n    // item\n    itemsSpacing: PropTypes.number,\n    itemWidth: PropTypes.number.isRequired,\n    itemHeight: PropTypes.number.isRequired,\n    itemDirection: PropTypes.oneOf([\n        'left-to-right',\n        'right-to-left',\n        'top-to-bottom',\n        'bottom-to-top',\n    ]),\n    itemTextColor: PropTypes.string,\n    itemBackground: PropTypes.string,\n    itemOpacity: PropTypes.number,\n\n    symbolShape: PropTypes.oneOfType([\n        PropTypes.oneOf(['circle', 'diamond', 'square', 'triangle']),\n        PropTypes.func,\n    ]),\n    symbolSize: PropTypes.number,\n    symbolSpacing: PropTypes.number,\n    symbolBorderWidth: PropTypes.number,\n    symbolBorderColor: PropTypes.string,\n\n    onClick: PropTypes.func,\n    onMouseEnter: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n\n    effects: PropTypes.arrayOf(\n        PropTypes.shape({\n            on: PropTypes.oneOfType([PropTypes.oneOf(['hover'])]).isRequired,\n            style: PropTypes.shape({\n                itemTextColor: PropTypes.string,\n                itemBackground: PropTypes.string,\n                itemOpacity: PropTypes.number,\n                symbolSize: PropTypes.number,\n                symbolBorderWidth: PropTypes.number,\n                symbolBorderColor: PropTypes.string,\n            }).isRequired,\n        })\n    ),\n}\n"],
  "mappings": "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",
  "names": ["categoricalColorSchemes", "nivo", "category10", "schemeCategory10", "accent", "schemeAccent", "dark2", "schemeDark2", "paired", "schemePaired", "pastel1", "schemePastel1", "pastel2", "schemePastel2", "set1", "schemeSet1", "set2", "schemeSet2", "set3", "schemeSet3", "categoricalColorSchemeIds", "Object", "keys", "divergingColorSchemes", "brown_blueGreen", "schemeBrBG", "purpleRed_green", "schemePRGn", "pink_yellowGreen", "schemePiYG", "purple_orange", "schemePuOr", "red_blue", "schemeRdBu", "red_grey", "schemeRdGy", "red_yellow_blue", "schemeRdYlBu", "red_yellow_green", "schemeRdYlGn", "spectral", "schemeSpectral", "divergingColorSchemeIds", "divergingColorInterpolators", "interpolateBrBG", "interpolatePRGn", "interpolatePiYG", "interpolatePuOr", "interpolateRdBu", "interpolateRdGy", "interpolateRdYlBu", "interpolateRdYlGn", "interpolateSpectral", "sequentialColorSchemes", "blues", "schemeBlues", "greens", "schemeGreens", "greys", "schemeGreys", "oranges", "schemeOranges", "purples", "schemePurples", "reds", "schemeReds", "blue_green", "schemeBuGn", "blue_purple", "schemeBuPu", "green_blue", "schemeGnBu", "orange_red", "schemeOrRd", "purple_blue_green", "schemePuBuGn", "purple_blue", "schemePuBu", "purple_red", "schemePuRd", "red_purple", "schemeRdPu", "yellow_green_blue", "schemeYlGnBu", "yellow_green", "schemeYlGn", "yellow_orange_brown", "schemeYlOrBr", "yellow_orange_red", "schemeYlOrRd", "sequentialColorSchemeIds", "sequentialColorInterpolators", "interpolateBlues", "interpolateGreens", "interpolateGreys", "interpolateOranges", "interpolatePurples", "interpolateReds", "turbo", "interpolateTurbo", "viridis", "interpolateViridis", "inferno", "magma", "plasma", "cividis", "interpolateCividis", "warm", "cool", "cubehelixDefault", "interpolateCubehelixDefault", "interpolateBuGn", "interpolateBuPu", "interpolateGnBu", "interpolateOrRd", "interpolatePuBuGn", "interpolatePuBu", "interpolatePuRd", "interpolateRdPu", "interpolateYlGnBu", "interpolateYlGn", "interpolateYlOrBr", "interpolateYlOrRd", "colorSchemes", "colorSchemeIds", "isCategoricalColorScheme", "scheme", "includes", "isDivergingColorScheme", "isSequentialColorScheme", "cyclicalColorInterpolators", "rainbow", "interpolateRainbow", "sinebow", "interpolateSinebow", "colorInterpolators", "colorInterpolatorIds", "getInheritedColorGenerator", "config", "theme", "_isPlainObject", "Error", "themeColor", "_get", "from", "getColor", "d", "Array", "isArray", "modifiers", "u", "modifier", "modifierType", "amount", "push", "color", "brighter", "darker", "opacity", "length", "datum", "reduce", "modify", "rgb", "toString", "useInheritedColor", "useMemo", "ordinalColorsPropType", "PropTypes", "oneOfType", "func", "arrayOf", "string", "shape", "oneOf", "isRequired", "size", "number", "inheritedColorPropType", "array", "getOrdinalColorScale", "config", "identity", "getIdentity", "datum", "_get", "Array", "isArray", "scale", "scaleOrdinal", "generator", "_isPlainObject", "scheme", "isCategoricalColorScheme", "colorSchemes", "isDivergingColorScheme", "size", "Error", "d", "isSequentialColorScheme", "useOrdinalColorScale", "useMemo", "SymbolCircle", "e", "x", "y", "size", "fill", "opacity", "c", "borderWidth", "d", "borderColor", "_jsx", "r", "cx", "cy", "strokeWidth", "stroke", "style", "pointerEvents", "SymbolDiamond", "transform", "SymbolSquare", "width", "height", "SymbolTriangle", "t", "zeroPadding", "top", "right", "bottom", "left", "computeDimensions", "t", "item", "direction", "itemsSpacing", "_padding", "padding", "itemCount", "itemWidth", "itemHeight", "Array", "isArray", "Error", "horizontalPadding", "verticalPadding", "width", "height", "spacing", "computePositionFromAnchor", "anchor", "translateX", "translateY", "containerWidth", "containerHeight", "x", "y", "computeItemLayout", "symbolX", "symbolY", "labelX", "labelY", "labelAnchor", "labelAlignment", "justify", "symbolSize", "symbolSpacing", "symbolByShape", "circle", "SymbolCircle", "diamond", "SymbolDiamond", "square", "SymbolSquare", "triangle", "SymbolTriangle", "LegendSvgItem", "c", "h", "g", "m", "f", "u", "v", "x", "y", "width", "height", "data", "direction", "B", "justify", "textColor", "background", "Y", "opacity", "T", "symbolShape", "symbolSize", "symbolSpacing", "symbolBorderWidth", "symbolBorderColor", "onClick", "onMouseEnter", "onMouseLeave", "toggleSerie", "effects", "useState", "style", "setStyle", "theme", "useTheme", "handleMouseEnter", "useCallback", "event", "filter", "t", "on", "reduce", "acc", "effect", "handleMouseLeave", "computeItemLayout", "symbolX", "symbolY", "labelX", "labelY", "labelAnchor", "labelAlignment", "isInteractive", "some", "handler", "SymbolShape", "_jsxs", "transform", "itemOpacity", "_jsx", "fill", "itemBackground", "cursor", "id", "createElement", "size", "color", "borderWidth", "borderColor", "hidden", "legends", "symbol", "undefined", "textAnchor", "text", "itemTextColor", "dominantBaseline", "pointerEvents", "userSelect", "label", "LegendSvg", "e", "padding", "_padding", "itemWidth", "itemHeight", "itemDirection", "itemsSpacing", "p", "b", "computeDimensions", "itemCount", "length", "xStep", "yStep", "map", "i", "left", "top", "BoxLegendSvg", "containerWidth", "containerHeight", "translateX", "a", "translateY", "anchor", "computePositionFromAnchor", "textAlignMapping", "start", "middle", "end", "renderLegendToCanvas", "ctx", "O", "save", "translate", "font", "fontSize", "fontFamily", "forEach", "d", "itemX", "itemY", "fillStyle", "fillRect", "textAlign", "textBaseline", "fillText", "String", "restore", "useQuantizeColorScaleLegendData", "t", "scale", "overriddenDomain", "domain", "reverse", "valueFormat", "v", "separator", "a", "useMemo", "items", "range", "map", "domainValue", "index", "invertExtent", "start", "end", "id", "extent", "label", "value", "color", "LegendPropShape", "data", "PropTypes", "arrayOf", "object", "anchor", "oneOf", "isRequired", "translateX", "number", "translateY", "direction", "itemsSpacing", "itemWidth", "itemHeight", "itemDirection", "itemTextColor", "string", "itemBackground", "itemOpacity", "symbolShape", "oneOfType", "func", "symbolSize", "symbolSpacing", "symbolBorderWidth", "symbolBorderColor", "onClick", "onMouseEnter", "onMouseLeave", "effects", "shape", "on", "style"]
}
